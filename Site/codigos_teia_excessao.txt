/*
 * radar-chart.js (Baseado no Original v16 + Nova Abordagem v8 - COMPLETO e CORRIGIDO FINAL)
 * Lógica para Gráficos de Teia (Radar) normais e pares especiais (TeiaPair).
 * Corrige criação/edição da tabela de perguntas e seletor de ID.
 */

const RadarChart = (() => {

    // Pega as configurações padrão globais
    const defaults = () => window.defaultTeiaSettings || {};

    // Função auxiliar para processar opções salvas/defaults (DEFINIDA PRIMEIRO)
    const processSavedOptions = (options, defaultTitle) => {
        const d = defaults();
        let processed = { ...d, ...options }; // Mescla
        // Ajusta estrutura de fontes se veio do formato antigo (fontsize array)
        if (processed.fontsize && Array.isArray(processed.fontsize)) {
            processed.titleFont = processed.titleFont ?? processed.fontsize[0] ?? d.fontsize[0];
            processed.categoryFont = processed.categoryFont ?? processed.fontsize[1] ?? d.fontsize[1];
            processed.legendFont = processed.legendFont ?? processed.fontsize[2] ?? d.fontsize[2];
        }
        // Garante que as propriedades de fonte existam (titleFont, categoryFont, legendFont)
        processed.titleFont = processed.titleFont ?? d.fontsize[0];
        processed.categoryFont = processed.categoryFont ?? d.fontsize[1];
        processed.legendFont = processed.legendFont ?? d.fontsize[2];
        delete processed.fontsize; // Remove a propriedade antiga 'fontsize'
        // Garante que o título seja string e usa o defaultTitle fornecido se o salvo for inválido
        if (!processed.hasOwnProperty('title') || processed.title === null || processed.title === undefined || String(processed.title).trim() === '') {
             processed.title = defaultTitle || d.title;
         } else {
             processed.title = String(processed.title || defaultTitle || d.title); // Garante que não seja nulo/undefined
         }
        // Remove pointLabelPadding explicitamente, pois não é mais configurável
        delete processed.pointLabelPadding;
        return processed; // Retorna as opções processadas e planas
    }; // Fim processSavedOptions


    // Função auxiliar para criar dados para sub-gráfico (MOVIDA DE SCRIPT.JS E ADAPTADA)
    const createSubChartData = (categoryCountsData, groupSizesMap, chartTitle) => {
        if (!categoryCountsData || Object.keys(categoryCountsData).length === 0) { console.log(`createSubChartData: Sem dados de contagem para ${chartTitle}`); return null; }
        const groupNames = Object.keys(categoryCountsData).sort();
        const allResponsesInCat = new Set();
        groupNames.forEach(group => { Object.keys(categoryCountsData[group] || {}).forEach(resp => allResponsesInCat.add(resp)); });
        const uniqueResponses = [...allResponsesInCat].sort();
        if (uniqueResponses.length === 0) { console.log(`createSubChartData: Sem respostas únicas (eixos) para ${chartTitle}`); return null; }
        const percentageData = groupNames.map(group => {
            const totalRespondents = groupSizesMap[group] || 0; const responseCountsForGroup = categoryCountsData[group] || {};
            return uniqueResponses.map(resp => { const count = responseCountsForGroup[resp] || 0; return totalRespondents > 0 ? Math.round((count / totalRespondents) * 100) : 0; });
        });
        const dfDados = { index: groupNames, columns: uniqueResponses, data: percentageData };
        // Retorna um objeto que a função 'plot' original espera (com dfDados e groupSizes)
        return { dfDados, title: chartTitle, groupSizes: groupSizesMap };
    }; // Fim createSubChartData


    // Função para configurar as opções ANINHADAS do Chart.js a partir de settings PLANAS
    const configureChartOptions = (settings, originalLabels = []) => {
        const d = defaults(); // Pega os defaults atuais
        // Destrutura as configurações planas recebidas (mescladas com defaults)
        const {
            title, pad_title, titleColor, legendPos, textColor, gridLinesColor,
            pointLabelMaxWidthPixels, enablePointLabelTruncation, pointLabelTruncateWords,
            categoryFont, titleFont, legendFont, adjustScale // adjustScale é usado em 'plot', não aqui diretamente
        } = { ...d, ...settings };

        // Define tamanhos de fonte
        const szTitle = titleFont ?? d.fontsize[0] ?? 16;
        const szPointLabel = categoryFont ?? d.fontsize[1] ?? 10;
        const szLegend = legendFont ?? d.fontsize[2] ?? 10;

        // Define cores para destaque (alto/baixo) e padrão
        const highColor = '#90EE90'; // Verde claro
        const lowColor = '#FFA07A'; // Salmão claro
        const defaultPointLabelColor = textColor ?? d.textColor ?? '#000000';

        // Lógica para identificar top/bottom 3 rótulos (para negrito)
        const numCategories = originalLabels.length;
        const top3Indices = numCategories >= 3 ? [0, 1, 2] : [...Array(numCategories).keys()];
        const bottom3Indices = numCategories >= 6 ? [numCategories - 1, numCategories - 2, numCategories - 3] :
                              (numCategories > 3 ? [...Array(numCategories - 3).keys()].map(i => i + 3) : []);
        const finalBottom3Indices = bottom3Indices.filter(idx => !top3Indices.includes(idx)); // Garante que não haja sobreposição

        const chartTitleString = String(title || ''); // Garante que título é string
        const displayTitle = !!chartTitleString.trim(); // Verifica se tem texto para exibir

        // Monta o objeto de opções aninhadas para Chart.js
        const nestedOptions = {
            plugins: {
                title: { // Configurações do título do gráfico
                    display: displayTitle, // Exibir ou não
                    text: chartTitleString, // Texto a ser renderizado (pode ser array para quebra de linha)
                    _intendedText: chartTitleString, // Guarda o texto original para referência e auto-wrap
                    font: { size: szTitle }, // Tamanho da fonte
                    color: titleColor ?? d.color_title, // Cor do texto
                    padding: { top: pad_title ?? 10, bottom: pad_title ?? 10 } // Espaçamento (usa default 10 se não especificado)
                },
                legend: { // Configurações da legenda (nomes dos grupos)
                    display: true, // Sempre exibir legenda por padrão
                    position: legendPos, // Posição (top, bottom, left, right)
                    labels: { font: { size: szLegend }, color: textColor ?? d.textColor } // Fonte e cor da legenda
                },
                tooltip: { // Configurações do tooltip que aparece ao passar mouse nos pontos
                    callbacks: {
                        // Função para formatar o TÍTULO do tooltip (geralmente o nome do eixo/categoria)
                        title: function(tooltipItems) {
                            if (!tooltipItems || tooltipItems.length === 0) return ''; // Retorna vazio se não houver item
                            const item = tooltipItems[0]; // Pega o primeiro item (geralmente só tem um)
                            const originalAxisLabel = item.label || ''; // Texto original do eixo
                            const chart = this.chart; // Instância do gráfico
                            const chartWidth = chart.width || 300; // Largura atual do canvas
                            const tooltipMaxWidth = chartWidth * 0.75; // Define largura máxima do tooltip
                            const ctx = chart.ctx; // Contexto do canvas para medir texto

                            // Se não puder medir, retorna o texto original
                            if (!ctx || tooltipMaxWidth <= 0 || typeof wrapText !== 'function') {
                                return originalAxisLabel;
                            }
                            // Obtém a configuração da fonte do título do tooltip
                            const tooltipTitleFont = chart.options.plugins?.tooltip?.titleFont || Chart.defaults.plugins.tooltip.titleFont;
                            const fontStyle = tooltipTitleFont.style || 'normal';
                            const fontWeight = tooltipTitleFont.weight || 'bold';
                            const fontSize = tooltipTitleFont.size || 12;
                            const fontFamily = tooltipTitleFont.family || Chart.defaults.font.family;

                            // Aplica a fonte ao contexto, quebra o texto e restaura a fonte original
                            const originalCtxFont = ctx.font;
                            ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
                            const wrappedTitleLines = wrapText(ctx, originalAxisLabel, tooltipMaxWidth); // Usa a função global wrapText
                            ctx.font = originalCtxFont;
                            return wrappedTitleLines; // Retorna um array de strings (linhas)
                        },
                        // Função para formatar CADA LINHA de dados dentro do tooltip
                        label: function(context) {
                            const datasetLabel = context.dataset.label || ''; // Nome do grupo (ex: Estudantes)
                            const value = Math.round(context.parsed?.r ?? 0); // Valor numérico do ponto (escala R)
                            return `${datasetLabel}: ${value}%`; // Formata como "Grupo: Valor%"
                        }
                    }
                }
                // O plugin 'titleAutoWrap' (definido em shared-utils) cuida da quebra de linha do título principal do gráfico
            },
            responsive: true, // Permite redimensionamento
            maintainAspectRatio: false, // Não mantém proporção fixa, preenche o container
            scales: {
                r: { // Configurações da escala radial (valores de 0 a 100%)
                    min: 0, // Valor mínimo da escala
                    angleLines: { display: false }, // Linhas que vão do centro aos eixos (desativadas)
                    grid: { color: gridLinesColor ?? d.gridLinesColor }, // Linhas circulares da grade
                    pointLabels: { // RÓTULOS EXTERNOS (nomes dos eixos/categorias/respostas)
                        padding: 0, // Padding fixado em 0 (sem espaço extra entre gráfico e rótulos)
                        // Função para formatar cada rótulo de eixo
                        callback: function(label, index) {
                            const chart = this.chart;
                            const originalLabelText = originalLabels[index] || '';
                            let textToDisplay = originalLabelText;

                            // Aplica truncagem por palavras, se habilitado nas opções
                            // ACESSA AS SETTINGS DIRETAMENTE DA INSTÂNCIA DO CHART NAS OPÇÕES ATUAIS
                            const currentSettings = chart.options?.__customSettings || settings; // Busca settings armazenadas ou usa as passadas
                            const currentEnableTruncation = currentSettings.enablePointLabelTruncation ?? d.enablePointLabelTruncation;
                            const truncateNumWords = currentSettings.pointLabelTruncateWords ?? d.pointLabelTruncateWords;
                            if (currentEnableTruncation) {
                                const words = originalLabelText.split(/\s+/);
                                if (words.length > truncateNumWords) {
                                    textToDisplay = words.slice(0, truncateNumWords).join(' ') + '...';
                                }
                            }

                            // Aplica quebra de linha por largura máxima em pixels
                            const ctx = chart.ctx;
                            const defaultMaxWidth = d.pointLabelMaxWidthPixels ?? 80;
                            const maxWidth = currentSettings.pointLabelMaxWidthPixels ?? defaultMaxWidth; // Usa valor das settings ou default

                            if (!ctx || maxWidth <= 0 || typeof wrapText !== 'function') {
                                return textToDisplay.includes('\n') ? textToDisplay.split('\n') : [textToDisplay];
                            }

                            // Obtém a fonte configurada para os rótulos dos pontos
                            const pointLabelFontCfg = chart.options.scales?.r?.pointLabels?.font || {};
                            const fontSize = pointLabelFontCfg.size ?? szPointLabel; // Usa a fonte do tema ou default
                            const isTopOrBottom = top3Indices.includes(index) || finalBottom3Indices.includes(index);
                            const currentFontWeight = isTopOrBottom ? 'bold' : 'normal'; // Aplica negrito
                            const fontStyle = pointLabelFontCfg.style || 'normal';
                            const fontFamily = pointLabelFontCfg.family || Chart.defaults.font.family;

                            // Mede e quebra o texto
                            const originalCtxFont = ctx.font;
                            ctx.font = `${fontStyle} ${currentFontWeight} ${fontSize}px ${fontFamily}`;
                            const wrappedLines = wrapText(ctx, textToDisplay, maxWidth);
                            ctx.font = originalCtxFont;
                            return wrappedLines; // Retorna array de linhas
                        },
                        font: { // Configurações da fonte dos rótulos dos eixos
                            size: szPointLabel,
                            weight: (ctx) => (top3Indices.includes(ctx.index) || finalBottom3Indices.includes(ctx.index)) ? 'bold' : 'normal' // Negrito dinâmico
                        },
                        color: (ctx) => { // Cor dinâmica (verde/vermelho para top/bottom)
                            if (top3Indices.includes(ctx.index)) return highColor;
                            if (finalBottom3Indices.includes(ctx.index)) return lowColor;
                            return defaultPointLabelColor; // Cor padrão
                        },
                        textAlign: 'center' // Alinhamento
                    },
                    ticks: { // Configurações dos marcadores numéricos da escala (0%, 20%...)
                        display: true, // Mostrar os números
                        stepSize: 20, // Intervalo (0, 20, 40...)
                        color: textColor ?? d.textColor, // Cor dos números
                        backdropColor: 'transparent', // Fundo atrás dos números (transparente)
                        callback: val => val + '%' // Adiciona sufixo '%'
                    }
                }
            }
        };
         // Armazena settings planas nas opções para referência no callback
        nestedOptions.__customSettings = settings;
        // A escala máxima (max) será definida na função 'plot' após ter os dados
        return nestedOptions;
    }; // Fim configureChartOptions


    // Função para plotar o gráfico (recebe dados pré-formatados de UM gráfico)
    const plot = (dataItemForPlot, options = {}, canvasId) => {
        const settings = { ...defaults(), ...options }; // Mescla opções recebidas com defaults
        const { figsize } = settings; // figsize é legado, mas pode ser usado se necessário
        const dfDados = dataItemForPlot.dfDados; // Espera { index: [grupos], columns: [eixos], data: [[valores]] }
        const groupSizes = dataItemForPlot.groupSizes || {}; // Tamanhos dos grupos (pode ser usado futuramente)

        // Validação crucial dos dados recebidos
        if (!dfDados || !dfDados.index || !dfDados.columns || !dfDados.data || dfDados.index.length === 0 || dfDados.columns.length === 0) {
            console.error("Plot Radar: Dados inválidos ou ausentes.", { canvasId, dataItemForPlot });
            const canvas = getEl(canvasId);
            if (canvas) {
                const parent = canvas.parentElement || canvas; // Tenta obter o wrapper
                parent.innerHTML = `<p class="error-msg" style="color: red; font-size:0.8em; text-align:center; padding:10px;">Erro: Dados inválidos para o gráfico ${canvasId.replace('chartCanvas_radar_','')}.</p>`;
            }
            return null; // Interrompe se dados inválidos
        }

        // Cria a estrutura 'datasets' para Chart.js a partir de dfDados
        const datasets = dfDados.index.map((groupName, i) => {
            const row = dfDados.data?.[i] || [];
            // Assume que os dados em dfDados.data JÁ SÃO as porcentagens calculadas em script.js
            const percentData = Array.isArray(row) ? row.map(val => parseFloat(val) || 0) : [];

            const d = defaults(); // Pega defaults para cores, etc.
            const color = settings.linesColor?.[i % settings.linesColor.length] ?? d.linesColor?.[i % d.linesColor.length] ?? '#cccccc';
            const radius = settings.pointRadius ?? d.pointRadius ?? 3;
            const hoverRadius = radius > 0 ? radius + 2 : 0;
            const hitRadius = 10; // Área de clique/hover para o ponto
            return {
                label: groupName, // Nome do grupo (ex: Estudantes)
                data: percentData, // Array de porcentagens para este grupo
                borderColor: color, // Cor da linha
                backgroundColor: 'transparent', // Fundo da área (transparente)
                borderWidth: settings.lineWidth ?? d.lineWidth, // Espessura da linha
                pointRadius: radius, // Tamanho do ponto
                pointBackgroundColor: color, // Cor de preenchimento do ponto
                pointBorderColor: settings.pointBorderColor ?? d.pointBorderColor, // Cor da borda do ponto
                pointHoverRadius: hoverRadius, // Tamanho do ponto no hover
                pointHoverBackgroundColor: color, // Cor do ponto no hover
                pointHoverBorderColor: settings.textColor ?? d.textColor ?? '#000', // Cor da borda no hover
                pointHitRadius: hitRadius, // Área de interação
                hidden: !(settings.datasetVisibility?.[i] ?? true) // Controla visibilidade inicial
            };
        });

        const originalLabels = [...dfDados.columns]; // Nomes dos eixos
        // Configura opções, passando as 'settings' planas para que callbacks (ex: pointLabels) possam acessá-las
        const chartOptionsNested = configureChartOptions(settings, originalLabels);

        // Ajusta a escala MÁXIMA agora que temos os 'datasets' criados
        if (chartOptionsNested.scales?.r) {
            chartOptionsNested.scales.r.max = settings.adjustScale ? undefined : 100; // Default 100 ou indefinido
            if (settings.adjustScale) { // Se ajuste habilitado...
                let maxVal = 0;
                datasets.forEach((ds) => { if (!ds.hidden) { maxVal = Math.max(maxVal, ...(ds.data || [0])); } });
                const targetMax = maxVal <= 0 ? 20 : Math.min(100, Math.ceil(maxVal / 20) * 20); // Calcula max (múltiplo de 20)
                chartOptionsNested.scales.r.max = targetMax; // Define o máximo calculado
            }
             if (chartOptionsNested.scales.r.ticks) chartOptionsNested.scales.r.ticks.stepSize = 20; // Garante step size
        } else {
            console.warn("Não foi possível configurar escala para RadarChart:", canvasId);
        }

        // Encontra o elemento canvas no DOM
        const canvas = getEl(canvasId);
        if (!canvas) { console.error("Canvas não encontrado:", canvasId); return null; }

        // Destroi gráfico anterior no mesmo canvas, se existir
        const existingChart = Chart.getChart(canvas);
        if (existingChart) { existingChart.destroy(); }

        // Tenta criar o novo gráfico Chart.js
        try {
            const ctx = canvas.getContext('2d');
            const chart = new Chart(ctx, {
                type: 'radar',
                data: { labels: originalLabels, datasets }, // Passa os eixos e os dados dos grupos
                options: chartOptionsNested // Passa as opções configuradas
            });
            // Aplica cor de fundo ao canvas
            chart.canvas.style.backgroundColor = settings.bgColor ?? defaults().bgColor;
            // figsize é legado, a responsividade deve cuidar disso
            if (figsize?.length === 2 && chart.resize) { console.warn("figsize setting is likely deprecated in Chart.js v3+."); }
            return chart; // Retorna a instância do gráfico
        } catch (error) {
            console.error(`Erro ao criar Chart.js para ${canvasId}:`, error);
            const parent = canvas.parentElement || canvas; // Tenta colocar erro no wrapper
            parent.innerHTML = `<p class="error-msg" style="color: red; font-size:0.8em; text-align:center; padding:10px;">Erro ao renderizar gráfico.</p>`;
            return null; // Retorna null em caso de erro
        }
    }; // Fim plot


    // --- Funções de Edição (Modal) ---

    // Constrói o HTML interno do modal de edição (COM nomes/spans restaurados e preview dupla condicional)
    const buildModalHTML = params => {
        const { title, titleFont, titleColor, legendPos, legendFont, textColor, bgColor, datasetNames, linesColor, pointBorderColor, categoryFont, gridLinesColor, datasetVisibility, lineWidth, pointRadius, adjustScale, pointLabelMaxWidthPixels, enablePointLabelTruncation, pointLabelTruncateWords, isSpecialPair } = params;
        const d = defaults(); const safeNames = datasetNames || [];
        const colorInputs = safeNames.map((name, i) => buildInput('color', `edit-line-color-${i}`, linesColor?.[i] || safeGet(d, `linesColor.${i}`, '#cccccc'), `Cor ${name || 'G' + (i+1)}`)).join('');
        const visibilityInputs = safeNames.map((name, i) => buildInput('checkbox', `edit-line-visibility-${i}`, datasetVisibility?.[i] ?? true, `Vis. ${name || 'G' + (i+1)}`)).join('');
        const legOpts = buildOptions(['top', 'right', 'bottom', 'left'], legendPos, d.legendPos);

        const previewContainerHTML = `
            <div class="graph-container ${isSpecialPair ? 'special-pair-preview' : ''}">
                <p class="preview-subtitle">Pré-visualização ${isSpecialPair ? '(Gráfico A)' : ''}</p>
                <canvas id="modalTeiaCanvas" style="min-height: ${isSpecialPair ? '250px' : '300px'}; width:100%; background-color:${bgColor ?? d.bgColor}; border: 1px solid #ccc;"></canvas>
                ${isSpecialPair ? `
                    <hr class="preview-separator">
                    <p class="preview-subtitle">Pré-visualização (Gráfico B)</p>
                    <canvas id="modalTeiaCanvasB" style="min-height: 250px; width:100%; background-color:${bgColor ?? d.bgColor}; border: 1px solid #ccc;"></canvas>
                ` : ''}
            </div>`;

        return `
            ${previewContainerHTML}
            <div class="settings-container">
                <h3>Editar Gráfico de Teia</h3>
                <div class="basic-settings">
                    ${buildInput('text','teia-edit-title',title ?? '', `Título ${isSpecialPair ? '(Categoria)' : ''}`)}
                    ${buildInput('number','teia-edit-title-font',titleFont ?? 16, 'Tam. Fonte Título', {props:{min:"10"}})}
                    ${buildInput('color','teia-edit-title-color',titleColor ?? '#000', 'Cor Título')}
                    ${buildInput('select','teia-edit-legend-pos','', 'Posição Legenda', {optionHTML: legOpts})}
                    ${colorInputs ? `<div class="settings-group group-settings-container"><h4>Cores Grupos</h4><div id="edit-lines-colors">${colorInputs}</div></div>` : '<p>Nenhum grupo para colorir.</p>'}
                    ${buildInput('color','teia-edit-bg-color',bgColor ?? '#fff', 'Cor Fundo Gráfico')}
                    <button id="teia-toggle-additional-btn">Mais Configurações</button>
                </div>
                <div class="additional-settings" style="display:none;">
                    ${visibilityInputs ? `<div class="settings-group group-settings-container"><h4>Visibilidade Grupos</h4><div id="edit-visibility-settings">${visibilityInputs}</div></div>` : '<p>Nenhum grupo para mostrar/esconder.</p>'}
                    ${buildInput('number','teia-edit-category-font',categoryFont ?? 10, 'Tam. Fonte Eixos', { props: { min: "8"} })}
                    ${buildInput('number','teia-edit-legend-font',legendFont ?? 10, 'Tam. Fonte Legenda', { props: { min: "8"} })}
                    ${buildInput('color','teia-edit-text-color',textColor ?? '#000', 'Cor Texto Geral (Eixos/Leg.)')}
                    ${buildInput('color','teia-edit-point-border-color',pointBorderColor ?? '#fff', 'Cor Borda Pontos')}
                    ${buildInput('color','teia-edit-grid-lines-color',gridLinesColor ?? '#ccc', 'Cor Linhas Fundo')}
                    ${buildInput('number','teia-edit-line-thickness-global',lineWidth ?? 2, 'Espessura Linha', { props: { min:"0.5", step:"0.5" } })}
                    ${buildInput('number','teia-edit-point-radius-global',pointRadius ?? 3, 'Tamanho Pontos', { props: { min:"0", step:"1" } })}
                    ${buildInput('checkbox','teia-edit-enable-point-label-truncation',enablePointLabelTruncation ?? true, 'Truncar Rótulos Eixos <span class="help-icon" data-help-key="truncarRotulo">?</span>')}
                    ${buildInput('number','teia-edit-point-label-truncate-words',pointLabelTruncateWords ?? 3, 'Nº Palavras (Truncar) <span class="help-icon" data-help-key="nPalavrasTruncar">?</span>', { props: { min: "1", step: "1" } })}
                    ${buildInput('number','teia-edit-point-label-max-width',pointLabelMaxWidthPixels ?? 80, 'Larg. Máx. Rótulo (px) <span class="help-icon" data-help-key="largMaxRotulo">?</span>', { props: { min: "30", step: "5" } })}
                    ${buildInput('checkbox','teia-adjust-scale',adjustScale ?? false, 'Ajustar Escala ao Máximo (%) <span class="help-icon" data-help-key="adjustScale">?</span>')}
                    <button id="teia-toggle-additional-btn-hide">Menos Configurações</button>
                </div>
                <div class="settings-buttons">
                    <div class="btn-group"><button id="teia-apply-btn">Aplicar</button><select id="teia-apply-scope"><option value="this">Neste</option><option value="all">Todos</option></select></div>
                    <div class="btn-group"><button id="teia-reset-btn">Padrão</button><select id="teia-reset-scope"><option value="this">Neste</option><option value="all">Todos</option></select></div>
                    <button id="teia-close-edit-btn">Cancelar</button>
                </div>
            </div>`;
    }; // Fim buildModalHTML

    // Lê os valores do formulário do modal
    const getFormValues = (datasetNames) => {
        const d = defaults(); const safeNames = datasetNames || [];
        return {
            title: getVal('teia-edit-title'), // Pega o título do input
            titleFont: getIntVal('teia-edit-title-font', 16), titleColor: getVal('teia-edit-title-color'), legendPos: getVal('teia-edit-legend-pos'), textColor: getVal('teia-edit-text-color'), bgColor: getVal('teia-edit-bg-color'), categoryFont: getIntVal('teia-edit-category-font', 10), legendFont: getIntVal('teia-edit-legend-font', 10), pointBorderColor: getVal('teia-edit-point-border-color'), linesColor: safeNames.map((_, i) => getVal(`edit-line-color-${i}`)), gridLinesColor: getVal('teia-edit-grid-lines-color'), lineWidth: getFloatVal('teia-edit-line-thickness-global', 2), pointRadius: getIntVal('teia-edit-point-radius-global', 3), pointLabelMaxWidthPixels: getIntVal('teia-edit-point-label-max-width', 80), enablePointLabelTruncation: isChecked('teia-edit-enable-point-label-truncation'), pointLabelTruncateWords: getIntVal('teia-edit-point-label-truncate-words', 3), datasetVisibility: safeNames.map((_, i) => isChecked(`edit-line-visibility-${i}`)), adjustScale: isChecked('teia-adjust-scale')
        };
     }; // Fim getFormValues

    // Aplica um objeto de configurações planas a UMA instância de gráfico
    const applySettings = (chart, newSettingsFlat) => {
        if (!chart?.config || !chart.data || !newSettingsFlat) { console.error("ApplySettings: Instância ou settings inválidas."); return; }
        const originalLabels = chart.config.data.labels || []; const chartData = chart.data; const d = defaults();
        // Guarda o título INTENCIONADO que veio nas settings (pode ser do form ou original)
        const intendedTitle = newSettingsFlat.title;
        let settingsToApply = { ...newSettingsFlat }; // Copia para não modificar original
        settingsToApply._intendedText = intendedTitle; // Armazena intenção original para auto-wrap

        const updatedChartOptionsNested = configureChartOptions(settingsToApply, originalLabels); // Configura com o título pretendido
        // Ajusta escala máxima com base nos dados e 'adjustScale'
        if (updatedChartOptionsNested.scales?.r) {
            updatedChartOptionsNested.scales.r.min = 0;
            if (settingsToApply.adjustScale) {
                let maxVal = 0; chartData.datasets.forEach((ds, i) => { if (!(settingsToApply.datasetVisibility?.[i] === false)) { maxVal = Math.max(maxVal, ...(ds.data || [0])); } });
                const targetMax = maxVal <= 0 ? 20 : Math.min(100, Math.ceil(maxVal / 20) * 20); updatedChartOptionsNested.scales.r.max = targetMax;
            } else { updatedChartOptionsNested.scales.r.max = 100; }
            if (updatedChartOptionsNested.scales.r.ticks) updatedChartOptionsNested.scales.r.ticks.stepSize = 20;
        }
        // Atualiza propriedades dos datasets
        chartData.datasets.forEach((ds, i) => {
            const defaultColor = d.linesColor?.[i % d.linesColor.length] ?? '#ccc'; const newColor = settingsToApply.linesColor?.[i] ?? defaultColor;
            const radius = settingsToApply.pointRadius ?? d.pointRadius ?? 3; const hoverRadius = radius > 0 ? radius + 2 : 0; const hitRadius = 10;
            Object.assign(ds, {
                borderColor: newColor, pointBackgroundColor: newColor, pointHoverBackgroundColor: newColor,
                pointBorderColor: settingsToApply.pointBorderColor ?? d.pointBorderColor,
                borderWidth: settingsToApply.lineWidth ?? d.lineWidth, pointRadius: radius,
                pointHoverRadius: hoverRadius, pointHitRadius: hitRadius,
                hidden: !(settingsToApply.datasetVisibility?.[i] ?? true)
            });
        });
        // Aplica cor de fundo e atualiza o gráfico
        if (chart.canvas) chart.canvas.style.backgroundColor = settingsToApply.bgColor ?? d.bgColor;
        chart.options = updatedChartOptionsNested; chart.update();
        // Armazena as opções planas APLICADAS na instância (incluindo o título)
        chart.currentOptions = JSON.parse(JSON.stringify(settingsToApply));
    }; // Fim applySettings

    // Reseta as configurações de UMA instância para os padrões
    const resetSettings = (chart) => {
        const d = defaults(); if (!chart?.config || !d) { console.error("ResetSettings: Instância inválida."); return; }
        // Tenta buscar o título original do DataItem correspondente
        let originalDataItemTitle = d.title; // Default
        const chartKey = Object.keys(window.charts).find(key => window.charts[key] === chart);
        if (chartKey) {
             const keyParts = chartKey.split('_'); const idPart = keyParts[1];
             const isSubChart = chart.currentOptions?.originalId && chart.currentOptions?.categoryName;
             let dataItemIdToFind = idPart;
             if(isSubChart) {
                  const originalCategoryName = chart.currentOptions.categoryName;
                  if (originalCategoryName) {
                       // Recria ID TeiaPair usando a categoria original armazenada
                       dataItemIdToFind = `${chart.currentOptions.originalId}_${originalCategoryName.replace(/[^a-zA-Z0-9]/g, '_')}`;
                   } else { dataItemIdToFind = chart.currentOptions?.originalId || idPart; } // Fallback
             }
             const dataItem = window.visualizacaoData?.[dataItemIdToFind];
             if(dataItem) {
                  if(dataItem.type === 'TeiaPair') {
                       const isChartB = chart.currentOptions?.originalId?.endsWith('b');
                       originalDataItemTitle = isChartB ? (dataItem.chartDataB?.title || d.title) : (dataItem.chartDataA?.title || d.title);
                   } else {
                       originalDataItemTitle = dataItem.title || d.title; // Teia Normal
                   }
              } else { console.warn(`DataItem ${dataItemIdToFind} não encontrado p/ reset.`); originalDataItemTitle = chart.options?.plugins?.title?._intendedText || d.title; }
        } else { console.warn("Chave do gráfico não encontrada p/ reset."); originalDataItemTitle = chart.options?.plugins?.title?._intendedText || d.title; }

        // Monta objeto com valores default, mas usando o título original encontrado
        const resetValuesFlat = {
            title: originalDataItemTitle, pad_title: d.pad_title, figsize: d.figsize,
            titleFont: d.fontsize[0], categoryFont: d.fontsize[1], legendFont: d.fontsize[2],
            color_title: d.color_title, legendPos: d.legendPos, linesColor: [...d.linesColor],
            gridLinesColor: d.gridLinesColor, bgColor: d.bgColor, lineWidth: d.lineWidth,
            pointRadius: d.pointRadius ?? 3, pointBorderColor: d.pointBorderColor,
            textColor: d.textColor ?? '#000000', pointLabelMaxWidthPixels: d.pointLabelMaxWidthPixels,
            enablePointLabelTruncation: d.enablePointLabelTruncation,
            pointLabelTruncateWords: d.pointLabelTruncateWords,
            datasetVisibility: chart.config.data.datasets.map(() => true), // Todos visíveis
            adjustScale: false // Desabilita ajuste de escala
        };
        applySettings(chart, resetValuesFlat); // Aplica os defaults (preserva título original encontrado)
    }; // Fim resetSettings

     // Reseta os campos do formulário do modal
     const updateModalFormWithDefaults = (defaultsToApply, representativeTitle, datasetNames = []) => {
        const safeDatasetNames = datasetNames || [];
        getEl('teia-edit-title').value = representativeTitle; // Mostra título representativo
        getEl('teia-edit-title-font').value = defaultsToApply.fontsize[0]; getEl('teia-edit-title-color').value = defaultsToApply.color_title;
        getEl('teia-edit-legend-pos').value = defaultsToApply.legendPos;
        const colorCont = getEl('edit-lines-colors'); if (colorCont) { colorCont.querySelectorAll('input[type="color"]').forEach((inp, i) => { inp.value = defaultsToApply.linesColor[i % defaultsToApply.linesColor.length]; }); }
        getEl('teia-edit-bg-color').value = defaultsToApply.bgColor; const visCont = getEl('edit-visibility-settings'); if (visCont) { visCont.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true); }
        getEl('teia-edit-category-font').value = defaultsToApply.fontsize[1]; getEl('teia-edit-legend-font').value = defaultsToApply.fontsize[2];
        getEl('teia-edit-text-color').value = defaultsToApply.textColor; getEl('teia-edit-point-border-color').value = defaultsToApply.pointBorderColor;
        getEl('teia-edit-grid-lines-color').value = defaultsToApply.gridLinesColor; getEl('teia-edit-line-thickness-global').value = defaultsToApply.lineWidth;
        getEl('teia-edit-point-radius-global').value = defaultsToApply.pointRadius;
        const checkTrunc = getEl('teia-edit-enable-point-label-truncation'); if(checkTrunc) checkTrunc.checked = defaultsToApply.enablePointLabelTruncation;
        getEl('teia-edit-point-label-truncate-words').value = defaultsToApply.pointLabelTruncateWords; getEl('teia-edit-point-label-max-width').value = defaultsToApply.pointLabelMaxWidthPixels;
        const checkScale = getEl('teia-adjust-scale'); if(checkScale) checkScale.checked = false;
     }; // Fim updateModalFormWithDefaults

    // Abre o modal de edição (ADAPTADO para TeiaPair)
    const openEditModal = (dataId) => {
        const dataItem = window.visualizacaoData?.[dataId]; if (!dataItem) { console.error("DataItem não encontrado:", dataId); alert(`Erro: Dados ${dataId} não encontrados.`); return; }
        const isSpecial = dataItem.type === 'TeiaPair'; let chartInstanceForModal; let representativeTitle = dataItem.title; let baseIdForSaving = dataId; let targetChartKeys = []; let dataItemForModal = dataItem;

        if (isSpecial) {
            console.log(`Abrindo modal TeiaPair ID: ${dataId}`); baseIdForSaving = dataItem.originalIds.a; const idA = dataItem.originalIds.a; const idB = dataItem.originalIds.b; const cat = dataItem.categoryName.replace(/[^a-zA-Z0-9]/g, '_'); const keyA = `radar_${idA}_${cat}`; const keyB = idB ? `radar_${idB}_${cat}` : null;
            chartInstanceForModal = window.charts[keyA] || (keyB ? window.charts[keyB] : null);
            if (window.charts[keyA]) targetChartKeys.push(keyA); if (keyB && window.charts[keyB]) targetChartKeys.push(keyB);
            representativeTitle = dataItem.categoryName;
            if (!chartInstanceForModal) { console.error(`Gráfico TeiaPair representativo não encontrado ${dataId}.`); alert(`Erro: Gráfico para ${dataItem.categoryName} não encontrado.`); return; }
        } else { console.log(`Abrindo modal Teia Normal ID: ${dataId}`); const chartKey = `radar_${dataId}`; chartInstanceForModal = window.charts[chartKey]; representativeTitle = dataItem.title; targetChartKeys = [chartKey]; baseIdForSaving = dataId; if (!chartInstanceForModal) { console.error(`Instância Teia Normal não encontrada: ${chartKey}`); alert(`Erro: Gráfico ${dataId} não encontrado.`); return; } }

        if (!chartInstanceForModal?.canvas || !chartInstanceForModal?.currentOptions || !chartInstanceForModal?.config?.options) { console.error("Instância representativa inválida:", dataId); alert(`Erro: Configs inválidas ${dataId}.`); return; }

        const d = defaults(); const currentFlatOptions = chartInstanceForModal.currentOptions; const datasets = chartInstanceForModal.config.data.datasets || []; const currentBgColorRGB = chartInstanceForModal.canvas.style.backgroundColor || currentFlatOptions.bgColor || d.bgColor; const currentBgColorHEX = typeof rgbToHex === 'function' ? rgbToHex(currentBgColorRGB) : '#fff'; let currentTitleText = representativeTitle; if (Array.isArray(currentTitleText)) currentTitleText = currentTitleText.join('\n');
        const settingsForModal = { isSpecialPair: isSpecial, bgColor: currentBgColorHEX, title: currentTitleText, titleFont: currentFlatOptions.titleFont ?? d.fontsize[0], titleColor: currentFlatOptions.titleColor ?? d.color_title, legendPos: currentFlatOptions.legendPos ?? d.legendPos, legendFont: currentFlatOptions.legendFont ?? d.fontsize[2], textColor: currentFlatOptions.textColor ?? d.textColor, categoryFont: currentFlatOptions.categoryFont ?? d.fontsize[1], pointBorderColor: currentFlatOptions.pointBorderColor ?? d.pointBorderColor, gridLinesColor: currentFlatOptions.gridLinesColor ?? d.gridLinesColor, lineWidth: currentFlatOptions.lineWidth ?? d.lineWidth, pointRadius: currentFlatOptions.pointRadius ?? d.pointRadius, adjustScale: currentFlatOptions.adjustScale ?? false, pointLabelMaxWidthPixels: currentFlatOptions.pointLabelMaxWidthPixels ?? d.pointLabelMaxWidthPixels, enablePointLabelTruncation: currentFlatOptions.enablePointLabelTruncation ?? d.enablePointLabelTruncation, pointLabelTruncateWords: currentFlatOptions.pointLabelTruncateWords ?? d.pointLabelTruncateWords, datasetNames: datasets.map(ds => ds.label || 'Grupo'), linesColor: currentFlatOptions.linesColor ?? datasets.map((_,i) => d.linesColor[i % d.linesColor.length]), datasetVisibility: currentFlatOptions.datasetVisibility ?? datasets.map(ds => !ds.hidden) };

        const overlay = createOverlay(); const modal = createEl('div', { classes: ['edit-modal', 'modal-component'] }); modal.innerHTML = buildModalHTML(settingsForModal); overlay.appendChild(modal);
        const modalCanvasA = getEl('modalTeiaCanvas'); const modalCanvasB = getEl('modalTeiaCanvasB'); let modalChartA = null; let modalChartB = null;

        if (modalCanvasA) {
             const modalCtxA = modalCanvasA.getContext('2d'); const previewDataA = JSON.parse(JSON.stringify(chartInstanceForModal.config.data || {})); let initialOptsA = {...settingsForModal};
             if (isSpecial) { initialOptsA.title = dataItemForModal.chartDataA?.title || representativeTitle + " (a)"; } else { initialOptsA.title = settingsForModal.title; }
             const initialPreviewOptionsA = configureChartOptions(initialOptsA, previewDataA.labels);
             if(initialPreviewOptionsA.scales?.r) { if(initialOptsA.adjustScale){let maxPA=0;previewDataA.datasets.forEach((ds,i)=>{if(!(initialOptsA.datasetVisibility?.[i]===false)){maxPA=Math.max(maxPA, ...(ds.data||[0]));}});initialPreviewOptionsA.scales.r.max=maxPA<=0?20:Math.min(100,Math.ceil(maxPA/20)*20);}else{initialPreviewOptionsA.scales.r.max=100;} if(initialPreviewOptionsA.scales.r.ticks)initialPreviewOptionsA.scales.r.ticks.stepSize=20;}
             previewDataA.datasets.forEach((ds, i) => { const dP=defaults(); const cP=initialOptsA.linesColor?.[i]??dP.linesColor[i%dP.linesColor.length]; const rP=initialOptsA.pointRadius??dP.pointRadius; Object.assign(ds,{borderColor:cP,pointBackgroundColor:cP,pointHoverBackgroundColor:cP,pointBorderColor:initialOptsA.pointBorderColor??dP.pointBorderColor,borderWidth:initialOptsA.lineWidth??dP.lineWidth,pointRadius:rP,pointHoverRadius:rP>0?rP+2:0,pointHitRadius:10,hidden:!(initialOptsA.datasetVisibility?.[i]??true)}); });
             modalChartA = new Chart(modalCtxA, { type: 'radar', data: previewDataA, options: initialPreviewOptionsA }); if (modalChartA.canvas) modalChartA.canvas.style.backgroundColor = initialOptsA.bgColor;
         }

         if (isSpecial && modalCanvasB && dataItemForModal.chartDataB?.dfDados) {
             const chartInstanceBKey = targetChartKeys.find(k => k.includes(dataItem.originalIds.b)); const chartInstanceB = chartInstanceBKey ? window.charts[chartInstanceBKey] : null;
             if (chartInstanceB) {
                 const modalCtxB = modalCanvasB.getContext('2d'); const previewDataB = JSON.parse(JSON.stringify(chartInstanceB.config.data || {}));
                 let initialOptsB = {...settingsForModal, title: dataItemForModal.chartDataB.title };
                 const initialPreviewOptionsB = configureChartOptions(initialOptsB, previewDataB.labels);
                 if(initialPreviewOptionsB.scales?.r) { if(initialOptsB.adjustScale){let maxPB=0;previewDataB.datasets.forEach((ds,i)=>{if(!(initialOptsB.datasetVisibility?.[i]===false)){maxPB=Math.max(maxPB, ...(ds.data||[0]));}});initialPreviewOptionsB.scales.r.max=maxPB<=0?20:Math.min(100,Math.ceil(maxPB/20)*20);}else{initialPreviewOptionsB.scales.r.max=100;} if(initialPreviewOptionsB.scales.r.ticks)initialPreviewOptionsB.scales.r.ticks.stepSize=20;}
                 previewDataB.datasets.forEach((ds, i) => { const dP=defaults(); const cP=initialOptsB.linesColor?.[i]??dP.linesColor[i%dP.linesColor.length]; const rP=initialOptsB.pointRadius??dP.pointRadius; Object.assign(ds,{borderColor:cP,pointBackgroundColor:cP,pointHoverBackgroundColor:cP,pointBorderColor:initialOptsB.pointBorderColor??dP.pointBorderColor,borderWidth:initialOptsB.lineWidth??dP.lineWidth,pointRadius:rP,pointHoverRadius:rP>0?rP+2:0,pointHitRadius:10,hidden:!(initialOptsB.datasetVisibility?.[i]??true)}); });
                 modalChartB = new Chart(modalCtxB, { type: 'radar', data: previewDataB, options: initialPreviewOptionsB }); if (modalChartB.canvas) modalChartB.canvas.style.backgroundColor = initialOptsB.bgColor;
             } else { modalCanvasB.outerHTML = '<p class="error-msg">Erro preview B.</p>'; }
         } else if (isSpecial && modalCanvasB) { modalCanvasB.outerHTML = '<p class="preview-subtitle" style="text-align:center; padding:20px;">Gráfico (b) sem dados.</p>'; }

        const updatePreview = () => {
            const formValues = getFormValues(settingsForModal.datasetNames);
            if (modalChartA) { let setA = {...formValues}; if(isSpecial) setA.title = dataItemForModal.chartDataA?.title || representativeTitle + " (a)"; else setA.title = formValues.title; applySettings(modalChartA, setA); }
            if (modalChartB) { let setB = {...formValues}; if(isSpecial) setB.title = dataItemForModal.chartDataB?.title || representativeTitle + " (b)"; applySettings(modalChartB, setB); }
        };
        modal.querySelectorAll('.settings-container input, .settings-container select').forEach(el => { const evt = (el.type === 'text' || el.type === 'number' || el.type === 'color') ? 'input' : 'change'; el.addEventListener(evt, updatePreview); });
        onClick('teia-toggle-additional-btn', () => { getEl('teia-toggle-additional-btn').style.display='none'; modal.querySelector('.additional-settings').style.display='block'; }); onClick('teia-toggle-additional-btn-hide', () => { getEl('teia-toggle-additional-btn').style.display='block'; modal.querySelector('.additional-settings').style.display='none'; });

        onClick('teia-apply-btn', () => {
            const newSettingsFromForm = getFormValues(settingsForModal.datasetNames); const scope = getVal('teia-apply-scope');
            const titleFromForm = newSettingsFromForm.title; let settingsToSave = { ...newSettingsFromForm };
            if (!isSpecial) { settingsToSave.title = titleFromForm; } else { delete settingsToSave.title; }

            const applyAction = (targetChartInstance, settings) => { let finalSettings = { ...settings }; if (!isSpecial) { finalSettings.title = titleFromForm; } applySettings(targetChartInstance, finalSettings); };

            if (scope === 'this') { targetChartKeys.forEach(key => { if (window.charts[key]) { applyAction(window.charts[key], newSettingsFromForm); } }); if(window.configTeia) window.configTeia[baseIdForSaving] = settingsToSave; }
            else { Object.keys(window.charts).filter(k => k.startsWith('radar_')).forEach(chartKey => { const inst = window.charts[chartKey]; if (inst) { applyAction(inst, newSettingsFromForm); let idSave = ''; if(inst.currentOptions?.originalId) { idSave = inst.currentOptions.originalId.endsWith('b') ? inst.currentOptions.originalId.slice(0, -1) : inst.currentOptions.originalId; } else { idSave = chartKey.substring(6); } if(idSave && window.configTeia) window.configTeia[idSave] = settingsToSave; } }); }
            console.log("Saving configs (simulated):", JSON.stringify(window.configTeia)); closeModal(overlay);
        });

        onClick('teia-reset-btn', () => {
            const scope = getVal('teia-reset-scope'); const resetAction = (inst) => { resetSettings(inst); };
            if (scope === 'this') { targetChartKeys.forEach(key => { if (window.charts[key]) resetAction(window.charts[key]); }); if(window.configTeia && window.configTeia[baseIdForSaving]) delete window.configTeia[baseIdForSaving]; }
            else { Object.keys(window.charts).filter(k => k.startsWith('radar_')).forEach(chartKey => { if (window.charts[chartKey]) resetAction(window.charts[chartKey]); }); window.configTeia = {}; }
            const gDefs = defaults(); let previewResetOpts = { ...gDefs, title: representativeTitle }; previewResetOpts = processSavedOptions(previewResetOpts, representativeTitle);
            if(modalChartA){ let resetA = {...previewResetOpts}; if(isSpecial) resetA.title = dataItemForModal.chartDataA?.title || representativeTitle+" (a)"; applySettings(modalChartA, resetA); }
            if(modalChartB){ let resetB = {...previewResetOpts}; if(isSpecial) resetB.title = dataItemForModal.chartDataB?.title || representativeTitle+" (b)"; applySettings(modalChartB, resetB); }
            updateModalFormWithDefaults(gDefs, representativeTitle, settingsForModal.datasetNames);
            console.log("Resetting configs (simulated):", JSON.stringify(window.configTeia)); closeModal(overlay);
        });

        onClick('teia-close-edit-btn', () => { closeModal(overlay); });
    }; // Fim openEditModal


    // --- Função de Inicialização (REFATORADA v6 - Correção Seletor e Tabela) ---
    const init = () => {
        const savedRadarConfigs = window.configTeia || {};
        const savedPerguntasConfigs = window.configPerguntas || {}; // As configs de perguntas salvas globalmente

        // Processa Teia Normal
        document.querySelectorAll('.square[data-type="grafico_de_teia"]').forEach((square) => {
            const dataId = square.getAttribute('data-id'); square.innerHTML = '';
            if (!dataId) { console.error("Square Teia Normal sem ID."); square.innerHTML = '<p class="error-msg">Erro: ID ausente.</p>'; return; }
            const dataItem = window.visualizacaoData?.[dataId];
            // Verifica se dataItem e as propriedades ESSENCIAIS existem
            if (!dataItem || dataItem.type !== 'Teia' || !dataItem.dfDados || !dataItem.groupSizes || !dataItem.dfPerg) {
                console.error(`Dados inválidos ou dfPerg ausente para Teia Normal ${dataId}.`);
                square.innerHTML = `<p class="error-msg">Erro: Dados ${dataId} inválidos.</p>`; return;
            }

            console.log(`Init Teia Normal: ${dataId}`);
            // --- Criação dos Elementos DOM para Teia Normal ---
            const chartWrapper = createEl('div', { classes: ['chart-wrapper'], style:'position:relative;height:70%;width:100%;' });
            const canvasId = `chartCanvas_radar_${dataId}`;
            const canvas = createEl('canvas', { attributes:{id:canvasId}, style:'width:100%;height:100%;' });
            const editBtn = createEl('button', { classes:['square-edit-btn','edit-chart-btn'], text:'Editar Gráfico' });
            editBtn.onclick = () => openEditModal(dataId); // Chama com ID normal

            const separator = createEl('div', { classes: ['perguntas-separator'] });
            const collapseBtn = createEl('button', { classes:['collapse-perguntas-btn'], html:'▼', attributes:{title:'Recolher/Expandir'} });
            separator.appendChild(collapseBtn);

            // ID do container da tabela (sanitizado para querySelector ou getElementById)
            const tableContainerId = `perguntasTable_radar_${dataId.replace(/\./g, '-')}`; // Substitui pontos por hífens
            const tableWrapper = createEl('div', { classes:['perguntas-table-wrapper'], id:tableContainerId });

            // Botão Editar Perguntas para Teia Normal
            const editPergBtn = createEl('button', { classes: ['square-edit-btn', 'edit-perguntas-btn'], text: 'Editar Perguntas' });
            editPergBtn.onclick = (e) => {
                e.stopPropagation();
                if(typeof PerguntasTable?.openEditModal === 'function'){
                    console.log(`[Teia Normal] Editando perguntas para dataId: ${dataId}`);
                    PerguntasTable.openEditModal(dataId); // Usa o dataId normal
                } else { console.error('PerguntasTable.openEditModal not found.'); }
            };
            tableWrapper.appendChild(editPergBtn); // Adiciona botão ao wrapper da tabela

            // Adiciona elementos ao square
            chartWrapper.append(canvas, editBtn); // Botão edit gráfico no wrapper do gráfico
            square.append(chartWrapper, separator, tableWrapper); // Adiciona tudo ao square

            // --- Plotagem do Gráfico e Tabela ---
            let initOptsChart = processSavedOptions(savedRadarConfigs[dataId] || {}, dataItem.title);
            const chart = plot(dataItem, initOptsChart, canvasId); // Passa dataItem normal
            if (chart) { const key = `radar_${dataId}`; window.charts[key] = chart; chart.currentOptions = JSON.parse(JSON.stringify(initOptsChart)); } else { console.error(`Falha Teia Normal ${dataId}.`); }

            // Plotar tabela de perguntas NORMAL
            if (dataItem.dfPerg?.data?.length > 0) {
                if (typeof PerguntasTable?.plot === 'function') {
                    // CORREÇÃO: Busca config salva diretamente de window.configPerguntas
                    const pOpts = window.configPerguntas?.[dataId] || {}; // <<<<<<<<<<<<<<< CORREÇÃO AQUI
                    const iPOpts = { ...(window.defaultPerguntasTableSettings||{}), ...pOpts };
                    console.log(`---> Chamando PerguntasTable.plot para Teia Normal ${dataId} em #${tableContainerId} com opções:`, iPOpts);
                    try {
                        // Chama plot com ID container sanitizado e ID referência normal
                        PerguntasTable.plot(dataItem.dfPerg, tableContainerId, iPOpts, dataId);
                    } catch (plotError) { console.error(`Erro durante PerguntasTable.plot para ${dataId}:`, plotError); tableWrapper.innerHTML = '<p class="error-msg">Erro ao renderizar tabela.</p>'; }
                } else { console.error("PerguntasTable.plot não encontrado."); tableWrapper.innerHTML = '<p class="error-msg">Erro Tabela (função não encontrada).</p>'; }
            } else { tableWrapper.innerHTML += '<p style="text-align:center; font-size:0.8em; color:#777; padding:10px;">Perguntas não disponíveis.</p>'; }
        }); // Fim forEach Teia Normal

        // Processa TeiaPair
        document.querySelectorAll('.square[data-type="teia_pair_special"]').forEach((square) => {
            const dataId = square.getAttribute('data-id'); square.innerHTML = ''; if (!dataId) { console.error("Square TeiaPair sem ID."); square.innerHTML = '<p class="error-msg">Erro: ID ausente.</p>'; return; }
            const dataItem = window.visualizacaoData?.[dataId]; if (!dataItem || dataItem.type !== 'TeiaPair' || !dataItem.originalIds || !dataItem.groupSizes || !dataItem.dfPerg) { /* Verifica dfPerg */ console.error(`Dados inválidos TeiaPair ${dataId}.`); square.innerHTML = `<p>Erro TeiaPair</p>`; return; }
            console.log(`Init TeiaPair: ${dataId}`); const baseId = dataItem.originalIds.a; const idA = dataItem.originalIds.a; const idB = dataItem.originalIds.b; const category = dataItem.categoryName; const sanCat = category.replace(/[^a-zA-Z0-9]/g, '_');
            square.appendChild(createEl('h4', { classes: ['teia-pair-category-title'], text: category })); const chartsRow = createEl('div', { classes: ['category-charts-row'] }); square.appendChild(chartsRow);

            // Plota Gráfico A
            if (dataItem.chartDataA?.dfDados) { const cIdA = `chartCanvas_radar_${idA}_${sanCat}`; const wA = createEl('div', { classes:['chart-wrapper','sub-chart'] }); const cA = createEl('canvas', { attributes:{id:cIdA}, style:'width:100%;height:100%;' }); const editBtnA = createEl('button', { classes: ['square-edit-btn', 'edit-sub-chart-btn'], text: 'Editar (a)' }); editBtnA.onclick = (e) => { e.stopPropagation(); openEditModal(dataId); }; wA.append(cA, editBtnA); chartsRow.appendChild(wA); let optsA = processSavedOptions(savedRadarConfigs[baseId] || {}, dataItem.chartDataA.title); optsA.categoryName = category; optsA.originalId = idA; const chartA = plot(dataItem.chartDataA, optsA, cIdA); if (chartA) { const key = `radar_${idA}_${sanCat}`; window.charts[key] = chartA; chartA.currentOptions = JSON.parse(JSON.stringify(optsA)); } else { console.error(`Falha sub-gráfico A: ${dataId}`); } } else { chartsRow.appendChild(createEl('div', {classes:['sub-chart-placeholder'], html:'<p>Gráfico (a)<br>sem dados.</p>'})); }
            // Plota Gráfico B
            if (dataItem.chartDataB?.dfDados) { const cIdB = idB ? `chartCanvas_radar_${idB}_${sanCat}` : ''; if (cIdB) { const wB = createEl('div', { classes:['chart-wrapper','sub-chart'] }); const cB = createEl('canvas', { attributes:{id:cIdB}, style:'width:100%;height:100%;' }); const editBtnB = createEl('button', { classes: ['square-edit-btn', 'edit-sub-chart-btn'], text: 'Editar (b)' }); editBtnB.onclick = (e) => { e.stopPropagation(); openEditModal(dataId); }; wB.append(cB, editBtnB); chartsRow.appendChild(wB); let optsB = processSavedOptions(savedRadarConfigs[baseId] || {}, dataItem.chartDataB.title); optsB.categoryName = category; optsB.originalId = idB; const chartB = plot(dataItem.chartDataB, optsB, cIdB); if (chartB) { const key = `radar_${idB}_${sanCat}`; window.charts[key] = chartB; chartB.currentOptions = JSON.parse(JSON.stringify(optsB)); } else { console.error(`Falha sub-gráfico B: ${dataId}`); } } else { console.warn(`ID B não encontrado p/ TeiaPair ${dataId}.`); chartsRow.appendChild(createEl('div', {classes:['sub-chart-placeholder'], html:'<p>Gráfico (b)<br>Inválido.</p>'})); } } else { chartsRow.appendChild(createEl('div', {classes:['sub-chart-placeholder'], html:'<p>Gráfico (b)<br>sem dados.</p>'})); }

            // Adiciona Tabela de Perguntas (UMA VEZ POR BASE ID)
            const tableContainerId = `perguntasTable_radar_${baseId.replace(/\./g, '-')}`; // ID SANITIZADO
            // Usa document.getElementById para buscar a tabela no DOCUMENTO TODO
            let tableWrapper = document.getElementById(tableContainerId); // Busca se já existe

            if (!tableWrapper && dataItem.dfPerg?.data?.length > 0) { // Só cria se NÃO existir E tiver dados
                 console.log(`   Adicionando tabela de perguntas para TeiaPair base ${baseId} (container: ${tableContainerId})`);
                 const separator = createEl('div',{classes:['perguntas-separator']}); const collBtn = createEl('button',{classes:['collapse-perguntas-btn'],html:'▼',attributes:{title:'Recolher/Expandir'}}); separator.appendChild(collBtn);
                 tableWrapper = createEl('div',{classes:['perguntas-table-wrapper'],id:tableContainerId}); // Cria o wrapper com ID sanitizado
                 const editPergBtn = createEl('button', { classes: ['square-edit-btn', 'edit-perguntas-btn'], text: 'Editar Perguntas' });
                 editPergBtn.onclick = (e) => { e.stopPropagation(); if(typeof PerguntasTable?.openEditModal === 'function'){ console.log(`Editando perguntas para baseId: ${baseId}`); PerguntasTable.openEditModal(baseId); } else { console.error('PerguntasTable.openEditModal not found.'); } };
                 tableWrapper.appendChild(editPergBtn); square.append(separator, tableWrapper); // Adiciona ao SQUARE ATUAL
                 if (typeof PerguntasTable?.plot === 'function') {
                      // CORREÇÃO: Busca config salva diretamente de window.configPerguntas
                      const pOpts = window.configPerguntas?.[baseId] || {}; // <<<<<<<<<<<<<<< CORREÇÃO AQUI
                      const iPOpts = { ...(window.defaultPerguntasTableSettings||{}), ...pOpts };
                      console.log(`---> Chamando PerguntasTable.plot para TeiaPair ${dataId} (base ${baseId}) em #${tableContainerId} com opções:`, iPOpts);
                      try {
                          PerguntasTable.plot(dataItem.dfPerg, tableContainerId, iPOpts, baseId); // Passa ID container sanitizado, baseId normal
                      } catch (plotError) { console.error(`Erro PerguntasTable.plot ${baseId} (TeiaPair ${dataId}):`, plotError); tableWrapper.innerHTML = '<p>Erro Tabela.</p>'; }
                  } else { console.error("PerguntasTable.plot não encontrado."); tableWrapper.innerHTML = '<p>Erro Tabela.</p>'; }
             } else if (!tableWrapper) { console.warn(`Sem perguntas para TeiaPair ${dataId} (base ${baseId})`); }
             else { console.log(`   Tabela para TeiaPair base ${baseId} já existe.`);}
        }); // Fim forEach TeiaPair

    }; // Fim init

    return { init, plot, openEditModal };

})(); // Fim IIFE










































































/*
 * script.js (REFATORADO para Nova Abordagem Teia Especial + FORÇAR TESTE)
 * Processes data from localStorage (TabelaConsulta, DemaisTabelas, savedChartConfigs)
 * Generates window.visualizacaoData for chart initialization.
 * Creates special 'TeiaPair' items for categorized Teia responses.
 */
document.addEventListener('DOMContentLoaded', () => {
    console.log("Processing data for visualization...");

    // --- Carrega Dados Essenciais ---
    const dadosCompletos = JSON.parse(localStorage.getItem("dadosCompletos"));
    // --- Carrega Configurações Salvas (se existirem) ---
    const savedConfigsString = localStorage.getItem('loadedChartConfigs');
    let savedChartConfigs = {};
    if (savedConfigsString) {
        try {
            savedChartConfigs = JSON.parse(savedConfigsString);
            console.log(`Loaded ${Object.keys(savedChartConfigs).length} saved chart/table configurations.`);
        } catch (e) {
            console.error("Error parsing savedChartConfigs from localStorage:", e);
        }
    } else {
        console.log("No saved chart configurations found in localStorage.");
    }

    // Validação dos dados essenciais das tabelas
    if (!dadosCompletos?.TabelaConsulta?.length || !dadosCompletos.DemaisTabelas) {
        console.error("Essential data ('TabelaConsulta', 'DemaisTabelas') missing or invalid in localStorage.");
        alert("Critical Error: Required data for visualizations not found. Check initial loading.");
        return;
    }

    const { TabelaConsulta: originalTabelaConsulta, DemaisTabelas: demaisTabelas } = dadosCompletos;
    console.log(`Data loaded. Response tables: ${Object.keys(demaisTabelas).length}`);

    // --- Helper Functions ---
    const isValidResponse = (value) => value != null && String(value).trim() !== '';

    // Função original para Teia normal (ainda usada para identificar tipo)
    const verificarCategoria = (categoria) => { // For Teia charts
        const catString = String(categoria ?? '').trim();
        if (!catString) return [];
        const partes = catString.split(/,\s*(?![^()]*\))/);
        const novasCategorias = [];
        if (partes.length > 0) { const primeiraParte = partes[0].trim(); if (primeiraParte) novasCategorias.push(primeiraParte); }
        for (let i = 1; i < partes.length; i++) {
            const parte = partes[i].trim();
            if (parte && (novasCategorias.length === 0 || /^[A-ZÀ-ÖØ-Ý]/.test(parte))) {
                novasCategorias.push(parte);
            } else if (novasCategorias.length > 0 && parte) {
                novasCategorias[novasCategorias.length - 1] += `, ${parte}`;
                novasCategorias[novasCategorias.length - 1] = novasCategorias[novasCategorias.length - 1].trim();
            }
        }
        return novasCategorias.filter(cat => cat);
    };

    /**
     * [NOVO] Detecta o formato especial "Resposta (Categoria)" e categoriza as respostas com CONTAGENS.
     */
    const detectAndCategorizeSpecialTeiaCounts = (rawResponsesArray) => {
        const categorizedCounts = {}; // { Categoria: { Resposta: contagem } }
        const foundCategories = new Set();
        let isStrictlySpecialFormat = false;
        let hasCheckedAtLeastOneValid = false;
        const specialPartRegex = /^([A-ZÀ-ÖØ-Ý][^,(]+?)\s+\(([^)]+)\)$/;

        for (const rawResponse of rawResponsesArray) {
            if (!isValidResponse(rawResponse)) continue;
            hasCheckedAtLeastOneValid = true;
            const responseString = String(rawResponse).trim();
            const parts = responseString.split(/,\s*/).map(p => p.trim()).filter(p => p !== '');

            if (parts.length === 0) { isStrictlySpecialFormat = false; break; }

            let currentResponseIsOk = true;
            const tempCategorizedForThisResponse = {};

            for (const part of parts) {
                const match = part.match(specialPartRegex);
                if (!match) { currentResponseIsOk = false; break; }
                const responseText = match[1].trim(); const category = match[2].trim();
                if (!tempCategorizedForThisResponse[category]) tempCategorizedForThisResponse[category] = {};
                if (!tempCategorizedForThisResponse[category][responseText]) tempCategorizedForThisResponse[category][responseText] = 0;
                tempCategorizedForThisResponse[category][responseText]++;
                foundCategories.add(category);
            }

            if (!currentResponseIsOk) { isStrictlySpecialFormat = false; break; }
            else {
                isStrictlySpecialFormat = true;
                for (const cat in tempCategorizedForThisResponse) {
                    if (!categorizedCounts[cat]) categorizedCounts[cat] = {};
                    for (const resp in tempCategorizedForThisResponse[cat]) {
                        if (!categorizedCounts[cat][resp]) categorizedCounts[cat][resp] = 0;
                        categorizedCounts[cat][resp] += tempCategorizedForThisResponse[cat][resp];
                    }
                }
            }
        }

        if (hasCheckedAtLeastOneValid && isStrictlySpecialFormat) {
            return { success: true, categorizedCounts, categories: [...foundCategories].sort() };
        } else {
            return { success: false };
        }
    }; // Fim detectAndCategorizeSpecialTeiaCounts

    // --- FUNÇÃO identificarTipoDeGrafico (COM MODIFICAÇÃO PARA TEIA ESPECIAL) ---
    const identificarTipoDeGrafico = (todasRespostas, infoGrupos) => {
        const respostasValidas = todasRespostas.filter(isValidResponse).map(r => String(r).trim());
        const totalRespostasConsideradas = todasRespostas.length;
        if (totalRespostasConsideradas > 0 && (totalRespostasConsideradas - respostasValidas.length) / totalRespostasConsideradas > 0.6) return 'Quadro de respostas abertas';
        if (!respostasValidas.length) return 'Quadro de respostas abertas';

        // Regra 2a: Detecção de Formato Teia Especial "Resposta (Categoria)"
        let isPotentiallySpecial = respostasValidas.length > 0;
        const specialPartRegexCheck = /^([A-ZÀ-ÖØ-Ý][^,(]+?)\s+\(([^)]+)\)$/;
        for(const resp of respostasValidas) {
            const parts = resp.split(/,\s*/).map(p => p.trim()).filter(p => p !== '');
             if(parts.length === 0 && resp !== '') { isPotentiallySpecial = false; break; }
             if (parts.length === 0 && resp === '') continue;
             for(const part of parts) { if (!specialPartRegexCheck.test(part)) { isPotentiallySpecial = false; break; } }
             if(!isPotentiallySpecial) break;
        }
        if (isPotentiallySpecial) { console.log("Type Decision: Teia (Rule 2a: Special Format)"); return 'Teia'; }

        // Regra 2b: Detecção de Teia Normal
        const ehTeiaNormal = respostasValidas.some(r => verificarCategoria(r).length > 1);
        if (ehTeiaNormal) { console.log("Type Decision: Teia (Rule 2b: Normal Format)"); return 'Teia'; }

        // Regra 3: Resposta Longa Única
        const frequencyMap = new Map(); respostasValidas.forEach(resp => { frequencyMap.set(resp, (frequencyMap.get(resp) || 0) + 1); });
        let foundUniqueLongAnswer = false;
        for (const [resp, count] of frequencyMap.entries()) { const wordCount = resp.split(/\s+/).filter(Boolean).length; if (count === 1 && wordCount > 6) { foundUniqueLongAnswer = true; break; } }
        if (foundUniqueLongAnswer) return 'Quadro de respostas abertas';

        // Regra 4: Barra vs Quadro
        const uniqueValidCount = frequencyMap.size; return uniqueValidCount <= 6 ? 'Barra' : 'Quadro de respostas abertas';
    }; // Fim identificarTipoDeGrafico

    const getColumnIndicesAndHeaders = (table, identificador) => {
        const header = table?.[0]; if (!header) return [];
        const regex = new RegExp(`\\s*\\[${identificador}\\]\\s*$`);
        return header.reduce((results, colName, j) => {
            if (typeof colName === 'string' && regex.test(colName.trim())) { const cleanHeaderText = colName.trim().replace(regex, '').trim(); results.push({ index: j, headerText: cleanHeaderText }); }
            return results;
        }, []);
    };

    // --- Part 1: Update Consultation Table with Chart Types ---
    const getUpdatedTabelaConsulta = () => {
        const headerConsulta = originalTabelaConsulta[0]; const indexNoGrafico = headerConsulta?.indexOf("No do gráfico");
        if (indexNoGrafico == null || indexNoGrafico === -1) { console.error("'No do gráfico' not found."); return null; }
        const novoHeader = [...headerConsulta.slice(0, indexNoGrafico + 1), "Tipo do gráfico", ...headerConsulta.slice(indexNoGrafico + 1)];
        const novaTabelaConsulta = [novoHeader];
        for (let i = 1; i < originalTabelaConsulta.length; i++) {
            const rowOriginal = originalTabelaConsulta[i]; const identificador = rowOriginal?.[indexNoGrafico];
            if (!identificador) { console.warn(`Row ${i + 1} missing identifier.`); continue; }
            const todasRespostas = [];
            for (const [, table] of Object.entries(demaisTabelas)) {
                 if (!table || table.length < 2) continue; const colunasInfo = getColumnIndicesAndHeaders(table, identificador);
                 if (colunasInfo.length > 0) { for (const colInfo of colunasInfo) { const resp = table.slice(1).map(row => (row && row.length > colInfo.index) ? row[colInfo.index] : undefined); todasRespostas.push(...resp); } }
            }
            const tipoGrafico = identificarTipoDeGrafico(todasRespostas);
            const novaLinha = [...rowOriginal.slice(0, indexNoGrafico + 1), tipoGrafico, ...rowOriginal.slice(indexNoGrafico + 1)];
            novaTabelaConsulta.push(novaLinha);
        }
        console.log(`TabelaConsulta updated with chart types for ${novaTabelaConsulta.length - 1} items.`);
        return novaTabelaConsulta;
    }; // Fim getUpdatedTabelaConsulta

    const tabelaConsultaAtualizada = getUpdatedTabelaConsulta();
    if (!tabelaConsultaAtualizada) { console.error("Failed to generate updated consultation table."); return; }

    // --- Separa Configurações Salvas por Tipo ---
    const separateConfigsByType = (allConfigs) => {
        const configBar = {}; const configTeia = {}; const configRespostas = {}; const configPerguntas = {};
        for (const key in allConfigs) {
            if (Object.hasOwnProperty.call(allConfigs, key)) {
                const config = allConfigs[key];
                if (key.startsWith('bar_')) { configBar[key.substring(4)] = config; }
                else if (key.startsWith('radar_')) { configTeia[key.substring(6)] = config; }
                else if (key.startsWith('table_')) { configRespostas[key.substring(6)] = config; }
                else if (key.startsWith('perguntas_')) { configPerguntas[key.substring(10)] = config; }
                else { console.warn(`Saved config with unknown/missing prefix: ${key}`); }
            }
        }
        return { configBar, configTeia, configRespostas, configPerguntas };
    }; // Fim separateConfigsByType

    const { configBar, configTeia, configRespostas, configPerguntas } = separateConfigsByType(savedChartConfigs);
    window.configBar = configBar; window.configTeia = configTeia; window.configRespostas = configRespostas; window.configPerguntas = configPerguntas;
    console.log("Saved configurations separated by type:", { Bar: Object.keys(configBar).length, Teia: Object.keys(configTeia).length, Respostas: Object.keys(configRespostas).length, Perguntas: Object.keys(configPerguntas).length });

    // --- [NOVO] Helper para Preparar Dados de Sub-Gráfico Teia ---
    const prepareChartDataFromCounts = (categoryCountsData, groupSizesMap, chartTitle) => {
        if (!categoryCountsData || Object.keys(categoryCountsData).length === 0) { return null; }
        const groupNames = Object.keys(categoryCountsData).sort();
        const allResponsesInCat = new Set();
        groupNames.forEach(group => { Object.keys(categoryCountsData[group] || {}).forEach(resp => allResponsesInCat.add(resp)); });
        const uniqueResponses = [...allResponsesInCat].sort();
        if (uniqueResponses.length === 0) return null;
        const percentageData = groupNames.map(group => {
            const totalRespondents = groupSizesMap[group] || 0; const responseCountsForGroup = categoryCountsData[group] || {};
            return uniqueResponses.map(resp => { const count = responseCountsForGroup[resp] || 0; return totalRespondents > 0 ? Math.round((count / totalRespondents) * 100) : 0; });
        });
        const dfDados = { index: groupNames, columns: uniqueResponses, data: percentageData };
        return { dfDados, title: chartTitle, groupSizes: groupSizesMap };
    }; // Fim prepareChartDataFromCounts

    // --- Part 2: Generate Final visualizacaoData JSON (REFATORADO para TeiaPair) ---
    const grupoParaNomeColunaPergunta = { "Estudantes": "Pergunta estudantes", "Ex-Estudantes": "Perg. ex-estudantes", "Familiares": "Perg. familiares", "Equipe Escolar": "Perg. equipe escolar" };
    const nomeColunaTitulo = "Título do gráfico"; const nomeColunaDimensao = "Dimensão"; const nomeColunaIndicador = "Indicador";
    const ordemCategoriasBarra = ['Bastante', 'Médio', 'Pouco', 'Nada', 'Outros'];

    const gerarVisualizacaoData = (consultaAtualizada, tabelasDados) => {
        const visualizacaoDataFinal = {};
        const intermediateSpecialTeiaData = {};
        const processedSpecialIds = new Set();

        const novoHeader = consultaAtualizada[0];
        const grupoSizesMap = Object.entries(tabelasDados).reduce((map, [fileName, table]) => { const grupo = fileName.replace(/\.xlsx?$/i, ""); map[grupo] = (table || []).slice(1).filter(row => row?.some(cell => isValidResponse(cell))).length; return map; }, {});
        const findIndex = (colName) => novoHeader.indexOf(colName);
        const indiceNoGrafico = findIndex("No do gráfico"); const indiceTipoGrafico = findIndex("Tipo do gráfico");
        const indicesPerguntas = Object.entries(grupoParaNomeColunaPergunta).reduce((acc, [grupo, colName]) => { acc[grupo] = findIndex(colName); return acc; }, {});
        const indiceTitulo = findIndex(nomeColunaTitulo); const indiceDimensao = findIndex(nomeColunaDimensao); const indiceIndicador = findIndex(nomeColunaIndicador);

        // --- Loop Principal: Processa cada linha da consulta ---
        for (let i = 1; i < consultaAtualizada.length; i++) {
            const linhaConsulta = consultaAtualizada[i]; if (!linhaConsulta) continue;
            const getVal = (index, clean = true) => { if (index === -1 || index >= linhaConsulta.length || linhaConsulta[index] == null) return null; const val = String(linhaConsulta[index]); return clean ? val.trim().replace(/\n/g, ' ') : val; };
            const identificador = getVal(indiceNoGrafico, false); const tipoGrafico = getVal(indiceTipoGrafico, false);
            if (!identificador || !tipoGrafico) { console.warn(`Row ${i + 1} missing ID or Type.`); continue; }

            const idParts = typeof identificador === 'string' ? identificador.split('.') : [];
            const numeroDimensao = idParts[0] || null; const numeroIndicador = idParts[1] || null;

            const currentItemData = {
                id: identificador, type: tipoGrafico, title: getVal(indiceTitulo) || `Vis. ${identificador}`,
                dimensionNumber: numeroDimensao, dimensionName: getVal(indiceDimensao) || `Dim. ${numeroDimensao || '?'}`,
                indicatorNumber: numeroIndicador, indicatorName: getVal(indiceIndicador) || `Ind. ${numeroIndicador || '?'}`,
                dfPerg: { columns: ['Grupo', 'Pergunta'], data: [] }, groupSizes: {}, subGroupToBaseGroup: {}
            };

            const rawDataPorSubGrupo = {}; const subGruposConsiderados = new Set();
            const subQuestionRegex = /(?:\n|^)\s*\(([a-zA-Z])\)/g;

            // Coleta rawDataPorSubGrupo e dfPerg
            for (const [fileName, table] of Object.entries(tabelasDados)) {
                const grupoBase = fileName.replace(/\.xlsx?$/i, ""); const indicePerguntaGrupo = indicesPerguntas[grupoBase];
                let perguntaCompleta = (indicePerguntaGrupo !== -1) ? getVal(indicePerguntaGrupo, false) : "";
                const colunasDadosInfo = getColumnIndicesAndHeaders(table, identificador); const markers = [...(perguntaCompleta || '').matchAll(subQuestionRegex)].map(match => match[1]);
                if (markers.length > 0 && tipoGrafico === 'Barra') {
                    const partesPergunta = (perguntaCompleta || '').split(subQuestionRegex);
                    for (let k = 0; k < markers.length; k++) {
                        if (k >= colunasDadosInfo.length) { console.warn(`Barra ${identificador}: More markers.`); break; }
                        const marker = markers[k]; const subGrupoNome = `${grupoBase} (${marker})`; const textoSubPergunta = (partesPergunta[2 * (k + 1)] || '').trim();
                        if (isValidResponse(textoSubPergunta)) { currentItemData.dfPerg.data.push([subGrupoNome, `(${marker}) ${textoSubPergunta}`]); }
                        else if (k===0 && partesPergunta[0] && isValidResponse(partesPergunta[0].trim())) { currentItemData.dfPerg.data.push([subGrupoNome, `(${marker}) ${partesPergunta[0].trim()}`]); }
                        const colInfo = colunasDadosInfo[k]; subGruposConsiderados.add(subGrupoNome); currentItemData.subGroupToBaseGroup[subGrupoNome] = grupoBase;
                        if (table?.length > 1 && colInfo.index < table[0].length) { if (!rawDataPorSubGrupo[subGrupoNome]) rawDataPorSubGrupo[subGrupoNome] = []; for (let r = 1; r < table.length; r++) { if (table[r]) rawDataPorSubGrupo[subGrupoNome].push(table[r][colInfo.index]); } }
                        else { rawDataPorSubGrupo[subGrupoNome] = []; }
                    }
                } else {
                    const grupoNomeFinal = grupoBase; const perguntaLimpada = perguntaCompleta?.trim().replace(/\n/g, ' ');
                    if (isValidResponse(perguntaCompleta)) { currentItemData.dfPerg.data.push([grupoNomeFinal, perguntaLimpada]); }
                    if (colunasDadosInfo.length > 0) {
                        if (colunasDadosInfo.length > 1 && tipoGrafico !== 'Quadro de respostas abertas' && tipoGrafico !== 'Teia') { console.warn(`ID ${identificador}: Multiple columns.`); }
                        const colInfo = colunasDadosInfo[0]; subGruposConsiderados.add(grupoNomeFinal); currentItemData.subGroupToBaseGroup[grupoNomeFinal] = grupoBase;
                        if (table?.length > 1 && colInfo.index < table[0].length) { if (!rawDataPorSubGrupo[grupoNomeFinal]) rawDataPorSubGrupo[grupoNomeFinal] = []; for (let r = 1; r < table.length; r++) { if (table[r]) rawDataPorSubGrupo[grupoNomeFinal].push(table[r][colInfo.index]); } }
                        else { rawDataPorSubGrupo[grupoNomeFinal] = []; }
                    } else if (isValidResponse(perguntaCompleta)) { subGruposConsiderados.add(grupoNomeFinal); currentItemData.subGroupToBaseGroup[grupoNomeFinal] = grupoBase; rawDataPorSubGrupo[grupoNomeFinal] = []; }
                }
            } // Fim loop tabelasDados

            // Atribui groupSizes
            subGruposConsiderados.forEach(subGrupo => { const baseGroup = currentItemData.subGroupToBaseGroup[subGrupo] || subGrupo; if (baseGroup && grupoSizesMap.hasOwnProperty(baseGroup)) { currentItemData.groupSizes[baseGroup] = grupoSizesMap[baseGroup]; if(subGrupo !== baseGroup) currentItemData.groupSizes[subGrupo] = grupoSizesMap[baseGroup]; } });
            const subGruposParaProcessar = [...subGruposConsiderados];

            // --- Processamento Específico por Tipo ---
            let isSpecialTeiaDetected = false;

            // ----- INÍCIO: CÓDIGO TEMPORÁRIO PARA FORÇAR CASO ESPECIAL PARA TESTE -----
            // !! REMOVA ou comente este bloco para usar a detecção real !!
            if (identificador === '4.5.1' || identificador === '4.5.1b') {
                console.warn(`>>> FORÇANDO MODO TEIA ESPECIAL PARA TESTE: ${identificador}`);
                isSpecialTeiaDetected = true; // Força a flag
                currentItemData.isSpecial = true; // Força a flag no item

                // Cria dados DUMMY com a estrutura de CONTAGENS
                const dummyCategories = ['Atividade de ensino-aprendizagem', 'Autogestão escolar', 'Conteúdo curricular'];
                currentItemData.foundCategories = dummyCategories;
                currentItemData.categorizedCounts = {
                    'Atividade de ensino-aprendizagem': {
                        'Estudantes': { 'Aulas teóricas': 2, 'Visitas de campo': 3, 'Trabalhos práticos': 1 },
                        'Equipe Escolar': { 'Aulas teóricas': 1, 'Visitas de campo': 2 }
                    },
                    'Autogestão escolar': {
                        'Estudantes': { 'Alojamento': 4, 'Regras de convivência': 2 },
                        'Equipe Escolar': { 'Alojamento': 3 }
                    },
                    'Conteúdo curricular': {
                        'Estudantes': { 'Ciências Humanas': 3, 'Matemática': 1 },
                        'Equipe Escolar': { 'Ciências Humanas': 2 }
                    }
                };
                console.log(`>>> Dados DUMMY (contagens) definidos para ${identificador}:`, currentItemData.categorizedCounts);

                // Armazena na estrutura intermediária (simulando detecção)
                const baseIdForce = identificador.endsWith('b') ? identificador.slice(0, -1) : identificador;
                const partKeyForce = identificador.endsWith('b') ? 'b' : 'a';
                if (!intermediateSpecialTeiaData[baseIdForce]) intermediateSpecialTeiaData[baseIdForce] = { a: null, b: null };
                intermediateSpecialTeiaData[baseIdForce][partKeyForce] = currentItemData;
                processedSpecialIds.add(identificador); // Marca como processado

            } else if (tipoGrafico === 'Teia') { // <<< Somente tenta detecção real se NÃO for forçado
            // ----- FIM: CÓDIGO TEMPORÁRIO ----- (A detecção real continua abaixo)

                // Tenta detectar o formato especial com contagens
                let aggregatedCounts = {}; let allCategoriesFound = new Set();
                let allGroupsConform = true; let checkedAtLeastOneGroup = false;
                for (const subGrupo of subGruposParaProcessar) {
                    const baseGroup = currentItemData.subGroupToBaseGroup[subGrupo] || subGrupo;
                    const rawResponses = rawDataPorSubGrupo[subGrupo] || [];
                    const result = detectAndCategorizeSpecialTeiaCounts(rawResponses);
                    checkedAtLeastOneGroup = checkedAtLeastOneGroup || result.success || rawResponses.some(isValidResponse);
                    if (!result.success && rawResponses.some(isValidResponse)) { allGroupsConform = false; break; }
                    if (result.success) {
                        result.categories.forEach(cat => allCategoriesFound.add(cat));
                        for (const category in result.categorizedCounts) {
                            if (!aggregatedCounts[category]) aggregatedCounts[category] = {}; if (!aggregatedCounts[category][baseGroup]) aggregatedCounts[category][baseGroup] = {};
                            const responseCounts = result.categorizedCounts[category];
                            for (const responseText in responseCounts) {
                                if (!aggregatedCounts[category][baseGroup][responseText]) aggregatedCounts[category][baseGroup][responseText] = 0;
                                aggregatedCounts[category][baseGroup][responseText] += responseCounts[responseText];
                            }
                        }
                    }
                } // Fim loop subGruposParaProcessar

                if (checkedAtLeastOneGroup && allGroupsConform && allCategoriesFound.size > 0) {
                    isSpecialTeiaDetected = true; // Marca detecção real
                    currentItemData.isSpecial = true; currentItemData.categorizedCounts = aggregatedCounts; currentItemData.foundCategories = [...allCategoriesFound].sort();
                    console.log(`>>> ID ${identificador} DETECTADO COMO TEIA ESPECIAL (Real). Categorias: ${currentItemData.foundCategories.join(', ')}`);
                    const baseId = identificador.endsWith('b') ? identificador.slice(0, -1) : identificador;
                    const partKey = identificador.endsWith('b') ? 'b' : 'a';
                    if (!intermediateSpecialTeiaData[baseId]) intermediateSpecialTeiaData[baseId] = { a: null, b: null };
                    intermediateSpecialTeiaData[baseId][partKey] = currentItemData;
                    processedSpecialIds.add(identificador);
                }
            } // Fim if/else if tipoGrafico === 'Teia'

            // --- Processa tipos NORMAIS (ou Teia não especial / não forçada) ---
            if (!isSpecialTeiaDetected && !processedSpecialIds.has(identificador)) {
                const potentialBaseId = identificador.endsWith('b') ? identificador.slice(0, -1) : null;
                if (!(potentialBaseId && intermediateSpecialTeiaData[potentialBaseId]?.a)) {
                    switch (tipoGrafico) {
                        case 'Barra': {
                            const respVal = {}; subGruposParaProcessar.forEach(sg => { respVal[sg] = (rawDataPorSubGrupo[sg] || []).filter(isValidResponse).map(r => String(r).trim()); });
                            const allRespFlat = Object.values(respVal).flat(); const catSet = new Set(allRespFlat);
                            const catsUnicas = [...catSet].sort((a, b) => { const iA=ordemCategoriasBarra.indexOf(a); const iB=ordemCategoriasBarra.indexOf(b); if(iA!==-1 && iB!==-1) return iA-iB; if(iA!==-1)return -1; if(iB!==-1)return 1; return a.localeCompare(b); });
                            currentItemData.dfDados = { index: [], columns: catsUnicas, data: [] };
                            subGruposParaProcessar.forEach(sg => { const hasQ = currentItemData.dfPerg.data.some(p => p[0] === sg); if ((respVal[sg]?.length > 0) || hasQ) { currentItemData.dfDados.index.push(sg); const respSG = respVal[sg] || []; currentItemData.dfDados.data.push(catsUnicas.map(cat => respSG.filter(r => r === cat).length)); } });
                            break;
                        }
                        case 'Teia': { // Teia Normal
                            const respValBase = {}; const totaisCatBase = {};
                            subGruposParaProcessar.forEach(sg => { const bg = currentItemData.subGroupToBaseGroup[sg] || sg; if (!respValBase[bg]) respValBase[bg] = []; const respSG = (rawDataPorSubGrupo[sg] || []).filter(isValidResponse).map(r=>String(r).trim()); respValBase[bg].push(...respSG); respSG.forEach(rs => { verificarCategoria(rs).forEach(c => { totaisCatBase[c] = (totaisCatBase[c] || 0) + 1; }); }); });
                            const catsUnicasT = Object.keys(totaisCatBase).sort((a,b) => (totaisCatBase[b]||0) - (totaisCatBase[a]||0) || a.localeCompare(b));
                            currentItemData.dfDados = { index: [], columns: catsUnicasT, data: [] };
                            Object.keys(respValBase).forEach(bg => { const hasQ = currentItemData.dfPerg.data.some(p => (currentItemData.subGroupToBaseGroup[p[0]] || p[0]) === bg); if ((respValBase[bg]?.length > 0) || hasQ) { currentItemData.dfDados.index.push(bg); currentItemData.dfDados.data.push(catsUnicasT.map(c => (respValBase[bg]||[]).filter(rs => verificarCategoria(rs).includes(c)).length)); } });
                            if (currentItemData.dfDados.index.length === 0 && subGruposParaProcessar.length > 0) { console.warn(`Teia Normal ${identificador}: No data aggregated.`); }
                            break;
                        }
                        case 'Quadro de respostas abertas': {
                            currentItemData.dfRespostas = {};
                            subGruposParaProcessar.forEach(sg => { const respSG = (rawDataPorSubGrupo[sg] || []).filter(isValidResponse).map(r => String(r).trim()); const hasQ = currentItemData.dfPerg.data.some(p => p[0] === sg); if (respSG.length > 0 || hasQ) { currentItemData.dfRespostas[sg] = respSG; } });
                            break;
                        }
                        default: {
                            console.warn(`Unhandled chart type "${tipoGrafico}" for item ${identificador}.`); currentItemData.type = 'NaoTratado';
                            currentItemData.dfRespostas = {}; subGruposParaProcessar.forEach(sg => { currentItemData.dfRespostas[sg] = (rawDataPorSubGrupo[sg] || []).filter(isValidResponse).map(r => String(r).trim()); });
                        }
                    } // Fim switch
                    const hasChartData = currentItemData.dfDados?.index?.length > 0; const hasResponseData = currentItemData.dfRespostas && Object.values(currentItemData.dfRespostas).some(arr => arr.length > 0); const hasQuestions = currentItemData.dfPerg?.data?.length > 0;
                    if (hasQuestions || hasChartData || hasResponseData) { visualizacaoDataFinal[identificador] = currentItemData; } else { console.log(`Item normal ${identificador} skipped.`); }
                }
            } // Fim if !isSpecialTeiaDetected
        } // --- Fim Loop Principal ---

        // --- Pós-Processamento: Cria Itens 'TeiaPair' ---
        console.log(`Processing ${Object.keys(intermediateSpecialTeiaData).length} potential Teia Special pairs.`);
        for (const baseId in intermediateSpecialTeiaData) {
            const pairData = intermediateSpecialTeiaData[baseId]; const dataItemA = pairData.a; const dataItemB = pairData.b;
            if (!dataItemA) { console.error(`Error: Data for part 'a' (${baseId}) not found.`); continue; }
            const allCategories = new Set([...(dataItemA.foundCategories || [])]); if (dataItemB?.foundCategories) { dataItemB.foundCategories.forEach(cat => allCategories.add(cat)); }
            const finalCategories = [...allCategories].sort(); if (finalCategories.length === 0) { console.warn(`No categories for pair ${baseId}.`); continue; }

            finalCategories.forEach(category => {
                const sanitizedCategory = category.replace(/[^a-zA-Z0-9]/g, '_'); const newItemId = `${baseId}_${sanitizedCategory}`;
                const chartDataA = prepareChartDataFromCounts( dataItemA.categorizedCounts?.[category], dataItemA.groupSizes, `${dataItemA.title || '(a)'} - ${category}` );
                let chartDataB = null; if (dataItemB?.categorizedCounts?.[category]) { chartDataB = prepareChartDataFromCounts( dataItemB.categorizedCounts[category], dataItemB.groupSizes, `${dataItemB.title || '(b)'} - ${category}` ); }
                let combinedPergData = JSON.parse(JSON.stringify(dataItemA.dfPerg)); if (dataItemB?.dfPerg?.data?.length > 0) { const existing = new Set(combinedPergData.data.map(r=>JSON.stringify(r))); dataItemB.dfPerg.data.forEach(rB => { if (!existing.has(JSON.stringify(rB))) { combinedPergData.data.push(rB); } }); }
                 const newItem = {
                    id: newItemId, type: "TeiaPair", title: category,
                    dimensionNumber: dataItemA.dimensionNumber, dimensionName: dataItemA.dimensionName, indicatorNumber: dataItemA.indicatorNumber, indicatorName: dataItemA.indicatorName,
                    categoryName: category, originalIds: { a: dataItemA.id, b: dataItemB?.id || null },
                    groupSizes: dataItemA.groupSizes, dfPerg: combinedPergData, chartDataA: chartDataA, chartDataB: chartDataB
                 };
                 if (newItem.chartDataA || newItem.chartDataB || newItem.dfPerg?.data?.length > 0) { visualizacaoDataFinal[newItemId] = newItem; }
                 else { console.warn(`TeiaPair ${newItemId} skipped.`); }
            });
        } // Fim loop intermediateSpecialTeiaData

        console.log(`Final visualizacaoData generated with ${Object.keys(visualizacaoDataFinal).length} items.`);
        return visualizacaoDataFinal;
    }; // Fim gerarVisualizacaoData

    // --- Final Assignment and Event Dispatch ---
    window.visualizacaoData = gerarVisualizacaoData(tabelaConsultaAtualizada, demaisTabelas);
    window.tabelaConsultaAtualizada = tabelaConsultaAtualizada;
    document.dispatchEvent(new CustomEvent('visualizacaoDataReady'));
    console.log("Data processing complete. 'visualizacaoDataReady' event dispatched.");
    console.log("Global 'visualizacaoData' and saved configs (window.configBar, etc.) are now available.");

}); // Fim DOMContentLoaded







































/*
 * main-init.js (MODIFICADO para TeiaPair)
 * Ponto de entrada principal para inicialização das visualizações.
 * 1. Espera o DOM carregar.
 * 2. Verifica se window.visualizacaoData está pronto (aguarda se necessário).
 * 3. Ordena os IDs dos gráficos (ex: 1.1.1, 1.2.1, 2.1.1, 4.5.1_Categoria).
 * 4. Extrai as dimensões únicas dos dados.
 * 5. Cria botões de filtro para cada dimensão e um botão "Todas".
 * 6. Itera sobre os IDs ordenados:
 *    - Insere subtítulos de Indicador quando o indicador muda.
 *    - Cria os elementos 'square' no HTML para cada item de visualização.
 *    - Adiciona classe 'special-teia-double-height' para tipo 'TeiaPair'.
 * 7. Adiciona um event listener aos botões de filtro.
 * 8. Chama as funções .init() dos módulos de gráfico/tabela.
 * 9. Configura listeners globais.
 */

document.addEventListener('DOMContentLoaded', () => {
    console.log("main-init.js: DOMContentLoaded disparado.");

    // Função auxiliar para comparar IDs (incluindo os novos com _Categoria)
    function compareIds(idA, idB) {
        // Trata IDs como strings para lidar com o formato "numero_Categoria"
        const strIdA = String(idA);
        const strIdB = String(idB);

        // Separa a parte numérica da parte da categoria (se existir)
        const partsA = strIdA.split('_');
        const partsB = strIdB.split('_');

        // Compara a parte numérica (ex: "4.5.1")
        const numericPartsA = partsA[0].split('.').map(n => parseInt(n, 10));
        const numericPartsB = partsB[0].split('.').map(n => parseInt(n, 10));

        for (let i = 0; i < Math.max(numericPartsA.length, numericPartsB.length); i++) {
            let valA = numericPartsA[i];
            let valB = numericPartsB[i];

            if (isNaN(valA) || isNaN(valB)) {
                // Se não for número, compara como string (raro aqui, mas seguro)
                const strPartA_Num = String(partsA[0]).split('.')[i] || '';
                const strPartB_Num = String(partsB[0]).split('.')[i] || '';
                if (isNaN(valA) && isNaN(valB)){
                     if (strPartA_Num !== strPartB_Num) return strPartA_Num.localeCompare(strPartB_Num);
                 } else return isNaN(valA) ? 1 : -1;
            } else if (valA !== valB) {
                return valA - valB; // Compara numericamente
            }
        }

        // Se a parte numérica for igual, compara pela parte da categoria (se existir)
        const categoryA = partsA[1] || ''; // String vazia se não houver categoria
        const categoryB = partsB[1] || '';

        if (categoryA !== categoryB) {
            return categoryA.localeCompare(categoryB); // Ordena alfabeticamente por categoria
        }

        // Se tudo for igual
        return 0;
    } // Fim compareIds


    function initializeVisualizations() {
        console.log("main-init.js: Iniciando criação de filtros, subtítulos, squares e inicialização...");

        // --- Seleção dos Elementos Essenciais ---
        const gridContainer = document.querySelector('.grid-container');
        const filterButtonsContainer = document.getElementById('dimension-filters');
        const dimensionTitleDisplay = document.getElementById('dimension-title');

        // --- Verificação da Existência dos Elementos ---
        if (!gridContainer || !filterButtonsContainer || !dimensionTitleDisplay) {
            console.error("Erro crítico: Elementos .grid-container, #dimension-filters ou #dimension-title não encontrados.");
            /* ... (mensagem de erro no body) ... */
            return;
        }

        // --- Limpeza Inicial ---
        gridContainer.innerHTML = ''; filterButtonsContainer.innerHTML = '';
        dimensionTitleDisplay.textContent = 'Carregando...';

        // --- Mapeamento de Tipos e Obtenção dos Dados ---
        const typeMapping = {
            'Barra': 'grafico_de_barras',
            'Teia': 'grafico_de_teia', // Teia Normal
            'Quadro de respostas abertas': 'quadro_de_respostas',
            'TeiaPair': 'teia_pair_special' // <<< NOVO TIPO MAPEADO
        };

        const visualizacaoData = window.visualizacaoData || {};
        let idsParaInicializar = Object.keys(visualizacaoData); // Pega as chaves (inclui os novos IDs _Categoria)

        // --- Ordenação dos IDs ---
        idsParaInicializar.sort(compareIds); // Ordena usando a função de comparação atualizada
        console.log("IDs ordenados para processamento:", idsParaInicializar);

        // --- Tratamento de Dados Vazios ---
        if (idsParaInicializar.length === 0) { /* ... (mensagem dados vazios) ... */ return; }

        // --- Lógica de Criação dos Botões de Filtro por Dimensão ---
        const dimensionsMap = new Map();
        Object.values(visualizacaoData).forEach(item => {
             if (item?.dimensionNumber && String(item.dimensionNumber).trim() !== "") {
                const dimNumStr = String(item.dimensionNumber).trim();
                 if (!dimensionsMap.has(dimNumStr)) { dimensionsMap.set(dimNumStr, item.dimensionName || `Dimensão ${dimNumStr}`); }
            }
        });
        const sortedDimensions = [...dimensionsMap.entries()].sort((a, b) => { /* ... (ordenação numérica das dimensões) ... */ });
        // Cria botão "Todas"
        const allButton = document.createElement('button'); allButton.className = 'filter-btn active';
        allButton.textContent = 'Todas as Dimensões'; allButton.dataset.dimension = 'all'; filterButtonsContainer.appendChild(allButton);
        // Cria botões para cada dimensão
        sortedDimensions.forEach(([dimNumber, dimName]) => {
            const dimButton = document.createElement('button'); dimButton.className = 'filter-btn';
            dimButton.textContent = `Dimensão ${dimNumber}`; dimButton.dataset.dimension = dimNumber;
            dimButton.title = dimName; filterButtonsContainer.appendChild(dimButton);
        });
        console.log(`main-init.js: ${filterButtonsContainer.children.length} botões de filtro criados.`);

        // --- Criação da Tabela de Informações e Contagem ---
        const infoTableContainer = document.getElementById('info-summary-table-container');
        if (infoTableContainer) {
            infoTableContainer.innerHTML = ''; // Limpa
            let schoolInfo = { name: 'N/A', city: 'N/A', state: 'N/A', responsible: 'N/A' };
            const storedSchoolInfo = localStorage.getItem("schoolInfo"); if (storedSchoolInfo) { try { /* ... parse schoolInfo ... */ } catch (e) { /* ... erro parse ... */ } }
            const respondentCounts = {}; const dadosCompletosLocal = JSON.parse(localStorage.getItem("dadosCompletos"));
            if (dadosCompletosLocal?.DemaisTabelas) { for (const [fileName, table] of Object.entries(dadosCompletosLocal.DemaisTabelas)) { const groupName = fileName.replace(/\.(xlsx?|csv)$/i, ""); const count = (table || []).slice(1).filter(row => row?.some(cell => cell != null && String(cell).trim() !== '')).length; respondentCounts[groupName] = count; } }
            console.log("Contagem de Respondentes por Grupo:", respondentCounts);
            const table = document.createElement('table'); table.id = 'info-summary-table'; const tbody = table.createTBody();
            const addRow = (label, value) => { const row = tbody.insertRow(); const th = document.createElement('th'); th.textContent = label; const td = document.createElement('td'); td.textContent = value; row.appendChild(th); row.appendChild(td); };
            const schoolHeaderRow = tbody.insertRow(); schoolHeaderRow.className = 'info-header'; const schoolHeaderCell = schoolHeaderRow.insertCell(); schoolHeaderCell.colSpan = 2; schoolHeaderCell.textContent = 'Informações da Escola';
            addRow('Escola:', schoolInfo.name); addRow('Local:', `${schoolInfo.city} / ${schoolInfo.state}`); addRow('Responsável:', schoolInfo.responsible);
            if (Object.keys(respondentCounts).length > 0) { const countHeaderRow = tbody.insertRow(); countHeaderRow.className = 'counts-header'; const countHeaderCell = countHeaderRow.insertCell(); countHeaderCell.colSpan = 2; countHeaderCell.textContent = 'Total de Respondentes por Grupo'; for (const [group, count] of Object.entries(respondentCounts)) { addRow(group + ':', count); } }
            infoTableContainer.appendChild(table);
        } else { console.error("Container #info-summary-table-container não encontrado."); }
        // --- FIM: Tabela de Informações ---


        // --- Criação dos Subtítulos de Indicador e Squares ---
        let currentIndicatorFullId = null; // Rastreia Dim.Ind

        // Itera sobre os IDs JÁ ORDENADOS
        idsParaInicializar.forEach(id => {
            const dataItem = visualizacaoData[id];
            if (!dataItem || !dataItem.type) { console.warn(`Dados inválidos para ID ${id}. Pulando.`); return; }

            // Usa o mapeamento ATUALIZADO que inclui TeiaPair
            const dataType = typeMapping[dataItem.type] || 'tipo_desconhecido';
            if (dataType === 'tipo_desconhecido') {
                console.warn(`Tipo "${dataItem.type}" para ID "${id}" não mapeado. Pulando.`); return;
            }

            // --- Lógica para Inserir Subtítulo do Indicador (mantida) ---
            if (dataItem.dimensionNumber && dataItem.indicatorNumber) {
                const itemIndicatorFullId = `${dataItem.dimensionNumber}.${dataItem.indicatorNumber}`;
                const itemIndicatorName = dataItem.indicatorName || `Indicador ${dataItem.indicatorNumber}`;
                if (itemIndicatorFullId !== currentIndicatorFullId) {
                    const subtitleElement = document.createElement('h3'); subtitleElement.className = 'indicator-subtitle';
                    subtitleElement.textContent = itemIndicatorName;
                    subtitleElement.setAttribute('data-indicator-full-id', itemIndicatorFullId);
                    subtitleElement.setAttribute('data-dimension-number', String(dataItem.dimensionNumber).trim());
                    gridContainer.appendChild(subtitleElement);
                    currentIndicatorFullId = itemIndicatorFullId;
                }
            } else { console.warn(`Item ${id} sem dimension/indicator number.`); }
            // --- FIM: Lógica do Subtítulo ---

            // --- Criação do Square ---
            const square = document.createElement('div');
            square.classList.add('square');
            square.setAttribute('data-type', dataType); // Usa o dataType mapeado (ex: 'teia_pair_special')
            square.setAttribute('data-id', id); // Usa o ID completo (ex: '4.5.1_Categoria')
            // Atributos para filtragem (mantidos)
            if (dataItem.dimensionNumber) { square.setAttribute('data-dimension-number', String(dataItem.dimensionNumber).trim()); }
            else { square.setAttribute('data-dimension-number', 'none'); }
            if (dataItem.dimensionNumber && dataItem.indicatorNumber) { square.setAttribute('data-indicator-full-id', `${dataItem.dimensionNumber}.${dataItem.indicatorNumber}`); }

            // ===========================================================
            // <<< INÍCIO: Adicionar classe para TeiaPair >>>
            // ===========================================================
            // Verifica o dataType MAPEADO
            if (dataType === 'teia_pair_special') {
                square.classList.add('special-teia-double-height');
                 // console.log(`Square ${id} (Type: TeiaPair) marcado com special-teia-double-height`);
            }
            // ===========================================================
            // <<< FIM: Adicionar classe para TeiaPair >>>
            // ===========================================================

            square.innerHTML = `<div class="loading-placeholder">Carregando ${id}...</div>`;
            gridContainer.appendChild(square);
            // --- FIM: Criação do Square ---
        });
        console.log(`main-init.js: ${gridContainer.querySelectorAll('.square').length} squares criados.`);
        console.log(`main-init.js: ${gridContainer.querySelectorAll('.indicator-subtitle').length} subtítulos de indicador criados.`);


        // --- Lógica de Filtragem por Dimensão (Event Listener nos Botões) ---
        filterButtonsContainer.addEventListener('click', (event) => {
            const clickedButton = event.target.closest('.filter-btn');
            if (clickedButton) {
                const selectedDimension = clickedButton.dataset.dimension;
                // 1. Atualiza botões
                filterButtonsContainer.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                clickedButton.classList.add('active');
                // 2. Atualiza título
                dimensionTitleDisplay.textContent = selectedDimension === 'all' ? 'Todas as Dimensões' : (dimensionsMap.get(selectedDimension) || `Dimensão ${selectedDimension}`);
                // 3. Filtra squares e subtítulos
                const allSquares = gridContainer.querySelectorAll('.square'); const allSubtitles = gridContainer.querySelectorAll('.indicator-subtitle');
                let visibleSquareCount = 0;
                allSquares.forEach(square => { const d = square.dataset.dimensionNumber; square.style.display = (selectedDimension === 'all' || d === selectedDimension) ? 'flex' : 'none'; if(square.style.display !== 'none') visibleSquareCount++; });
                allSubtitles.forEach(subtitle => { const d = subtitle.dataset.dimensionNumber; subtitle.style.display = (selectedDimension === 'all' || d === selectedDimension) ? 'block' : 'none'; });
                console.log(`Filtro aplicado: Dimensão '${selectedDimension}'. ${visibleSquareCount} squares visíveis.`);
            }
        });
        // --- FIM: Lógica de Filtragem ---

        dimensionTitleDisplay.textContent = 'Todas as Dimensões'; // Título inicial

        // --- Chamada dos Inicializadores dos Módulos de Gráfico/Tabela ---
        console.log("main-init.js: Chamando inicializadores dos módulos...");
        // Os inicializadores (RadarChart.init, etc.) agora precisam saber como lidar
        // com os diferentes data-types ('grafico_de_teia' vs 'teia_pair_special')
        if (typeof BarChart !== 'undefined' && BarChart.init) BarChart.init();
        else console.error("Módulo BarChart não carregado ou não possui init().");
        if (typeof RadarChart !== 'undefined' && RadarChart.init) RadarChart.init();
        else console.error("Módulo RadarChart não carregado ou não possui init().");
        if (typeof ResponseTable !== 'undefined' && ResponseTable.init) ResponseTable.init();
        else console.error("Módulo ResponseTable não carregado ou não possui init().");
        console.log("main-init.js: Inicialização dos módulos solicitada.");

    } // --- Fim da função initializeVisualizations ---


    // --- Lógica para Aguardar os Dados e Chamar a Inicialização ---
    if (window.visualizacaoData && Object.keys(window.visualizacaoData).length > 0) {
        console.log("main-init.js: window.visualizacaoData encontrado. Iniciando.");
        initializeVisualizations();
    } else {
        console.log("main-init.js: Aguardando 'visualizacaoDataReady'.");
        const handleDataReady = () => {
            console.log("main-init.js: Evento 'visualizacaoDataReady' recebido.");
            if (window.visualizacaoData && Object.keys(window.visualizacaoData).length > 0) {
                console.log("main-init.js: Iniciando após evento.");
                initializeVisualizations();
            } else {
                console.error("Erro crítico: 'visualizacaoDataReady' disparado, mas dados inválidos.");
                /* ... (mensagem de erro) ... */
            }
        };
        document.addEventListener('visualizacaoDataReady', handleDataReady, { once: true });

        // Fallback com timeout (mantido)
        setTimeout(() => {
            document.removeEventListener('visualizacaoDataReady', handleDataReady);
            const hasFilterButtons = document.querySelector('#dimension-filters .filter-btn');
            if (!hasFilterButtons) {
                 if (window.visualizacaoData && Object.keys(window.visualizacaoData).length > 0) {
                      console.log("main-init.js: Iniciando no timeout.");
                      initializeVisualizations();
                 } else {
                     console.error("Erro crítico: Timeout esperando dados.");
                     /* ... (mensagem de erro) ... */
                 }
            } else { console.log("main-init.js: Timeout, mas parece já inicializado."); }
        }, 5000); // Timeout 5s
    }


    // --- Listeners Globais (edição, collapse, fechar modal) ---
    // 1. Listener para Botões de Edição (Precisa ser atualizado para TeiaPair)
   // --- Listeners Globais (edição, collapse, fechar modal) ---
    // 1. Listener para Botões de Edição
    document.body.addEventListener('click', (e) => {
        const editBtn = e.target.closest('.edit-chart-btn');
        const editPerguntasBtn = e.target.closest('.edit-perguntas-btn');
        if (!editBtn && !editPerguntasBtn) return;

        const buttonClicked = editBtn || editPerguntasBtn;
        const square = buttonClicked.closest('.square'); if (!square) return;
        const dataIdFromSquare = square.getAttribute('data-id'); if (!dataIdFromSquare) return;
        const dataType = square.getAttribute('data-type'); // Pega o tipo do square

        if (editPerguntasBtn) {
            // Lógica Editar Perguntas
            console.log(`Botão Editar Perguntas clicado para Square ID=${dataIdFromSquare}, Type=${dataType}`);

            // Determina o ID correto a ser passado para PerguntasTable
            let idParaPerguntasTable = dataIdFromSquare; // Default: usa o ID do square

            // === INÍCIO: AJUSTE PARA TeiaPair ===
            if (dataType === 'teia_pair_special') {
                 // Se for TeiaPair, extrai o baseId (parte antes do último '_')
                 const parts = dataIdFromSquare.split('_');
                 if (parts.length > 1) {
                    // Assume que a última parte é a categoria sanitizada, o resto é o baseId.join('_')
                    // Mas como nossos IDs são simples (numero.numero.numero_cat), só pegar a primeira parte funciona.
                    // Para ser mais robusto, poderíamos pegar tudo menos a última parte.
                    // const baseIdDetected = parts.slice(0, -1).join('_'); // Mais robusto se ID base tivesse '_'
                     const baseIdDetected = parts[0]; // Pega '4.5.1' de '4.5.1_Categoria'
                     if (baseIdDetected) {
                         idParaPerguntasTable = baseIdDetected;
                         console.log(`   Tipo TeiaPair detectado. Usando Base ID para tabela: ${idParaPerguntasTable}`);
                     } else {
                          console.warn(`   Não foi possível extrair baseId de TeiaPair ID: ${dataIdFromSquare}`);
                          // Mantém idParaPerguntasTable como dataIdFromSquare como fallback
                     }
                 } else {
                      console.warn(`   TeiaPair ID ${dataIdFromSquare} não tem formato esperado com '_'`);
                 }
            }
             // === FIM: AJUSTE PARA TeiaPair ===

            // Chama openEditModal com o ID correto (original ou baseId)
            if (typeof PerguntasTable !== 'undefined' && PerguntasTable.openEditModal) {
                 if (!window.defaultPerguntasTableSettings) { console.error("defaultPerguntasTableSettings não encontrado."); return; }
                 console.log(`   Chamando PerguntasTable.openEditModal com ID: ${idParaPerguntasTable}`);
                 PerguntasTable.openEditModal(idParaPerguntasTable); // << USA O ID CORRETO
            } else { console.error("PerguntasTable.openEditModal não está disponível.");}

        } else if (editBtn) {
            // Lógica Editar Principal (Gráfico/Tabela)
            // (A lógica aqui já estava correta, chamando RadarChart.openEditModal com dataIdFromSquare)
             if (!dataType) return;
             console.log(`Botão Editar Principal clicado para: ID=${dataIdFromSquare}, Type=${dataType}`);
            switch (dataType) {
                case 'grafico_de_barras':
                    if (typeof BarChart !== 'undefined' && BarChart.openEditModal) BarChart.openEditModal(dataId);
                    else console.error("BarChart.openEditModal não encontrado."); break;
                case 'grafico_de_teia': // Teia Normal
                case 'teia_pair_special': // <<< TEIA ESPECIAL TAMBÉM CHAMA RadarChart.openEditModal
                    if (typeof RadarChart !== 'undefined' && RadarChart.openEditModal) RadarChart.openEditModal(dataId); // Passa o ID (normal ou _Categoria)
                    else console.error("RadarChart.openEditModal não encontrado."); break;
                case 'quadro_de_respostas':
                    if (typeof ResponseTable !== 'undefined' && ResponseTable.openEditModal) ResponseTable.openEditModal(dataId);
                    else console.error("ResponseTable.openEditModal não encontrado."); break;
                default: console.warn("Tipo de dado não reconhecido para edição:", dataType);
            }
        }
    });

    // 2. Listener para Botões de Collapse/Expand (sem mudanças)
    document.body.addEventListener('click', (e) => {
        const collapseBtn = e.target.closest('.collapse-perguntas-btn'); if (!collapseBtn) return;
        const square = collapseBtn.closest('.square'); if (!square) return;
        const tableWrapper = square.querySelector('.perguntas-table-wrapper');
        if (tableWrapper) { tableWrapper.classList.toggle('collapsed'); collapseBtn.classList.toggle('collapsed'); }
    });

    // 3. Listener Global para Fechar Modais (sem mudanças)
    document.body.addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay') && e.target.classList.contains('modal-component')) {
             if (typeof closeModal === 'function') { closeModal(e.target); }
             else { console.warn("Função global closeModal não encontrada."); }
        }
    });
    console.log("main-init.js: Listeners globais configurados.");


    // --- Sidebar de Download (sem mudanças) ---
    const openBtn = document.getElementById('open-download-sidebar-btn');
    const closeBtn = document.getElementById('close-download-sidebar-btn');
    const sidebar = document.getElementById('download-sidebar');
    if (openBtn && closeBtn && sidebar) {
        console.log("Sidebar toggle elements found.");
        openBtn.addEventListener('click', () => { sidebar.classList.add('open'); openBtn.classList.add('hidden'); });
        closeBtn.addEventListener('click', () => { sidebar.classList.remove('open'); openBtn.classList.remove('hidden'); });
        document.body.addEventListener('click', (event) => { if (sidebar.classList.contains('open') && !sidebar.contains(event.target) && event.target !== openBtn) { sidebar.classList.remove('open'); openBtn.classList.remove('hidden'); } }, true);
    } else { console.error("Could not find all sidebar toggle elements."); }
    if (typeof DownloadHandler !== 'undefined' && DownloadHandler.init) { DownloadHandler.init(); }
    else { console.error("DownloadHandler not found or does not have init()."); }

}); // Fim do DOMContentLoaded

















































/* ========================================== */
/* === ESTILOS PARA TEIA ESPECIAL (TeiaPair) === */
/* ========================================== */

/* 1. Garante a altura dupla para o square TeiaPair */
.square.special-teia-double-height {
    height: 1200px; /* Altura aumentada - ajuste fino pode ser necessário */
    /* Mantém o flex column para organizar os blocos (título categoria, linha charts, tabela) */
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* Alinha conteúdo no topo */
}

/* 2. Container que agrupa TODAS as categorias dentro do square */
/*    Este container terá scroll se o conteúdo vertical exceder a altura */
.special-teia-all-categories {
    width: 100%;
    flex-grow: 1; /* Faz este container ocupar o espaço vertical disponível */
    overflow-y: auto; /* Adiciona scroll vertical se necessário */
    overflow-x: hidden; /* Evita scroll horizontal desnecessário */
    padding: 10px; /* Espaçamento interno */
    box-sizing: border-box;
    /* border: 1px dashed blue; */ /* Para debug visual */
}

/* 3. Estilo para o título H4 de CADA categoria */
.teia-pair-category-title {
    text-align: center;
    margin: 10px 0 15px 0; /* Espaçamento acima/abaixo */
    padding: 6px;
    font-size: 1.15em; /* Um pouco maior */
    font-weight: 600;
    color: #334;
    background-color: #e8f0fe; /* Fundo azul claro (similar a subtítulo indicador) */
    border-radius: 4px;
    border-bottom: 1px solid #b0c4de;
}

/* 4. Grupo de UMA categoria (contém título H4 e a linha de gráficos) */
/*    Ajusta espaçamento entre grupos de categorias */
.category-chart-group {
    margin-bottom: 25px; /* Espaço abaixo de cada grupo */
    padding-bottom: 20px;
    border-bottom: 1px dashed #ccc; /* Linha separadora entre categorias */
}
.category-chart-group:last-child {
    border-bottom: none; /* Remove a borda do último grupo */
    margin-bottom: 10px; /* Menos margem no final */
}

/* 5. Linha que contém os wrappers dos gráficos A e B */
.category-charts-row {
    display: flex; /* Coloca os wrappers lado a lado */
    flex-direction: row; /* Garante direção de linha */
    justify-content: space-around; /* Espaça A e B */
    align-items: stretch; /* Tenta fazer A e B terem a mesma altura */
    flex-wrap: wrap; /* Permite quebrar se tela for muito estreita */
    gap: 15px; /* Espaço entre A e B */
    width: 100%; /* Ocupa toda a largura disponível */
    box-sizing: border-box;
    /* border: 1px dashed red; */ /* Para debug visual */
}

/* 6. Wrapper INDIVIDUAL de cada sub-gráfico (A ou B) */
/*    Este é o container direto do canvas */
.square.special-teia-double-height .chart-wrapper.sub-chart {
    position: relative; /* Para posicionamento de botões internos se necessário */
    /* Define a base da largura - tenta ser ~metade menos o gap */
    flex-basis: calc(50% - 10px);
    /* Garante que não cresça além da base (para manter 2 colunas) */
    flex-grow: 0;
    /* Permite encolher se necessário (embora min-width limite) */
    flex-shrink: 1;
    /* Define uma largura mínima para evitar colapso */
    min-width: 300px;
    /* ALTURA: Vamos usar uma altura relativa ou min-height */
    height: 420px; /* ALTURA FIXA - Ajuste este valor! É crucial para o layout */
    /* min-height: 350px; */ /* Alternativa: altura mínima */
    /* aspect-ratio: 1 / 0.9; */ /* Alternativa: proporção */

    border: 1px solid #e0e0e0; /* Borda sutil */
    background-color: #ffffff; /* Fundo branco */
    padding: 8px; /* Padding interno */
    box-sizing: border-box;
    box-shadow: 0 1px 2px rgba(0,0,0,0.05);

    /* Para centralizar o canvas se ele for menor que o wrapper */
    display: flex;
    justify-content: center;
    align-items: center;
}

/* 7. Placeholder para quando Gráfico A ou B não tem dados */
.square.special-teia-double-height .sub-chart-placeholder {
    flex-basis: calc(50% - 10px);
    flex-grow: 0; flex-shrink: 1;
    min-width: 300px;
    height: 420px; /* Mesma altura do sub-chart */
    min-height: 350px;
    border: 1px dashed #ccc;
    background-color: #f9f9f9;
    padding: 8px;
    box-sizing: border-box;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-style: italic;
    color: #888;
    font-size: 0.9em;
}


/* 8. Garante que o canvas dentro do sub-chart seja responsivo */
.square.special-teia-double-height .chart-wrapper.sub-chart canvas {
    max-width: 100%;
    max-height: 100%;
    display: block; /* Remove espaço extra */
}

/* 9. Ajustes para a tabela e separador no TeiaPair */
.square.special-teia-double-height .perguntas-separator,
.square.special-teia-double-height .perguntas-table-wrapper {
    flex-shrink: 0; /* Impede que encolham */
}

.square.special-teia-double-height .perguntas-table-wrapper {
    max-height: 250px; /* Altura máxima para scroll da tabela (pode ajustar) */
    /* A altura restante do flex container será usada pelo .special-teia-all-categories */
}

/* 10. Botão de Edição Geral para o TeiaPair */
.square.special-teia-double-height > .edit-chart-btn {
    /* Estilos mantidos da versão anterior (absolute, bottom, right, etc.) */
     position: absolute;
     bottom: 10px;
     right: 10px;
     z-index: 20;
     background-color: #e4d0b5;
     border: 1px solid #ccc;
     padding: 6px 12px;
     font-size: 14px;
     cursor: pointer;
     border-radius: 4px;
     opacity: 0; /* Escondido por padrão */
     transition: opacity 0.3s ease-in-out;
     pointer-events: none; /* Não interage quando escondido */
}
.square.special-teia-double-height:hover > .edit-chart-btn {
    opacity: 1; /* Mostra no hover do square */
    pointer-events: auto; /* Permite clique */
}








































css estilizado:


/* Estilo principal */
body {
    font-family: Arial, sans-serif;
    background-color: #f5f5dc;
    margin: 0;
    padding-bottom: 120px; /* Ajuste este valor se necessário */
    display: flex;
    justify-content: center;  /* Centraliza o conteúdo no eixo horizontal */
}

.container {
    width: 80%;
    margin: 0 auto;
    padding: 20px;
    text-align: center;
    flex-grow: 1;
}

h1 {
    color: #333;
}

h2 {
    color: #555;
    margin: 15px 0;
}



/*------------------------Upload Style----------------------------------*/
.upload-btn-container {
    margin: 20px 0;
    display: flex;
    flex-direction: column; /* Coloca os botões um abaixo do outro */
    align-items: flex-start; /* Garante que os botões fiquem alinhados à esquerda */
}

.upload-btn {
    display: inline-flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    margin: 5px 0; /* Para garantir que os botões fiquem empilhados */
    padding: 10px 20px;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    min-width: 200px; /* Mantém a largura mínima */
    width: auto; /* Ajusta para largura automática, ou define como necessário */
    box-sizing: border-box; /* Certifica-se de que o padding seja considerado no cálculo da largura */
}

.upload-btn:hover {
    background-color: #d2b89f;
}

#add-response-btn {
    margin-top: 10px; /* Garante que o botão '+' fique abaixo dos outros */
    padding: 10px 20px;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    cursor: pointer;
    font-size: 20px;
    transition: background-color 0.3s;
    width: 50px; /* Define uma largura fixada para o botão '+' */
    align-self: flex-start; /* Garante que o botão "+" fique alinhado à esquerda */
}

#add-response-btn:hover {
    background-color: #d2b89f;
}

#responses-container {
    display: flex;
    flex-direction: column; /* Garante que os inputs de resposta fiquem em uma coluna */
    gap: 10px; /* Espaçamento entre os botões de upload */
}

/* Adiciona uma classe extra para os botões gerados dinamicamente, com largura 100% */
.upload-btn.dynamic-upload-btn {
    width: 100%; /* Faz com que os botões gerados dinamicamente ocupem 100% da largura disponível */
}

/* Ícone de status dentro do botão */
.upload-status {
    font-size: 1.2em;
}

/* Ícones de sucesso e erro */
.success {
    color: green;
}

.error {
    color: red;
}


input[type="file"] {
    display: none;
}
/*-------------------------------------------------------------------------*/


.continue-btn, .back-btn {
    display: inline-block;
    margin-top: 20px;
    padding: 10px 20px;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    text-decoration: none;
}

.continue-btn:hover, .back-btn:hover {
    background-color: #d2b89f;
}

.buttons button {
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 10px 20px;
    margin: 10px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
}

/* Botão de Voltar */
.back-btn {
    position: fixed;
    top: 20px; /* Distância do topo da página */
    left: 20px; /* Distância da borda esquerda */
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 10px 20px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
    text-decoration: none;
}

.back-btn:hover {
    background-color: #d2b89f;
}



.main-header {
    display: flex;
    justify-content: center; /* Centraliza H1 e botão */
    align-items: center;
    position: relative; /* Para posicionar o botão absoluto se necessário */
    margin-bottom: 20px; /* Espaço abaixo do header */
}

.main-header h1 {
    margin: 15; /* Remove margem padrão do H1 */
    margin-right: 15px; /* Espaço entre H1 e botão */
}

.sidebar-toggle-btn {
    padding: 8px 12px;
    font-size: 14px;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s, opacity 0.4s;
    opacity: 1; /* Visível por padrão */
}
.sidebar-toggle-btn:hover {
    background-color: #d2b89f;
}
.sidebar-toggle-btn.hidden {
    opacity: 0; /* Esconde o botão de abrir quando sidebar está aberta */
    pointer-events: none;
}



/* Sidebar */
.sidebar {
    position: fixed;
    right: 0;
    top: 0;
    width: 300px; /* Largura da sidebar */
    height: 100%;
    background-color: #f8f9fa; /* Cor de fundo um pouco diferente */
    padding: 20px;
    padding-top: 50px; /* Espaço para botão fechar */
    box-shadow: -3px 0 6px rgba(0, 0, 0, 0.15);
    box-sizing: border-box;
    z-index: 1300; /* <<< NOVO VALOR: Maior que o footer, menor que o modal */
    display: flex;
    flex-direction: column;
    align-items: stretch; /* Estica botões */
    overflow-y: auto;

    transform: translateX(100%); /* Começa fora da tela */
    transition: transform 0.4s ease-in-out; /* Animação de slide */
}

.sidebar.open {
    transform: translateX(0%); /* Entra na tela */
}

.sidebar h2 {
    text-align: center;
    margin-top: 0;
    margin-bottom: 25px;
    font-size: 1.2em;
    color: #333;
}

.sidebar .download-btn { /* Reutiliza/Ajusta estilo existente */
    display: block;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 10px 15px; /* Padding ajustado */
    margin-bottom: 15px; /* Espaçamento ajustado */
    cursor: pointer;
    font-size: 14px; /* Fonte ajustada */
    width: 100%;
    box-sizing: border-box;
    transition: background-color 0.3s;
    text-align: center;
    color: #333;
    border-radius: 4px;
}
.sidebar .download-btn:hover {
    background-color: #d2b89f;
}

.sidebar .dimension-input-container { /* Reutiliza/Ajusta estilo */
    margin-bottom: 15px;
    width: 100%;
    display: flex; /* Alinha botão e input */
    flex-direction: column;
}
.sidebar .dimension-input-container button {
    border-bottom-left-radius: 0;
    border-bottom-right-radius: 0;
     margin-bottom: 0; /* Remove espaço extra */
     border-bottom: none; /* Junta visualmente com input */
}
.sidebar .dimension-input-container input {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
    padding: 10px;
    font-size: 14px;
    border: 1px solid #ccc;
}

.sidebar .sidebar-close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    font-size: 24px; /* Tamanho do 'X' */
    font-weight: bold;
    color: #888;
    cursor: pointer;
    line-height: 1;
    padding: 5px;
}
.sidebar .sidebar-close-btn:hover {
    color: #333;
}

.sidebar .download-note {
    font-size: 0.8em;
    color: #666;
    text-align: center;
    margin-top: auto; /* Empurra para baixo */
    padding-top: 15px;
}

/* Estilo para os quadrados */
.grid-container {
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 2 colunas */
    gap: 30px; /* Espaço entre os quadrados */
    justify-items: center; /* Centralizar os quadrados */
    margin-top: 20px;
}

.square {
    position: relative;
    width: 100%;
    max-width: 600px;
    height: 700px; /* Altura FIXA do quadrado é importante */
    border: 2px solid #000;
    background-color: #f0f0f0;
    display: flex;            /* <<< GARANTIR FLEX */
    flex-direction: column; /* <<< GARANTIR COLUNA */
    justify-content: flex-start;
    align-items: stretch;
    overflow: hidden;
    transition: box-shadow 0.3s ease;
    padding: 5px; /* Mantém o padding do square */
    box-sizing: border-box;
}

.square-content {
    font-size: 16px;
    font-weight: bold;
    text-align: center;
}

/* Wrapper para o gráfico */
.chart-wrapper {
    flex-grow: 1;       /* <<< TENTA FAZER ELE CRESCER por padrão */
    flex-shrink: 1;     /* Permite encolher se necessário */
    min-height: 400px;  /* Mantém altura mínima */
    position: relative;
    width: 100%;
    box-sizing: border-box;
    transition: height 0.4s ease-out, flex-grow 0.4s ease-out; /* Adiciona transição para flex-grow */
    overflow: hidden; /* Esconde overflow do gráfico */
}

.chart-wrapper.chart-expanded {
    /* Altura total do .square (100%) menos a altura do .perguntas-separator (25px) */
    /* Subtrai também o padding do .square se houver (ex: 5px em cima e 5px em baixo) */
    height: calc(100% - 25px - 10px); /* 100% - separador - (padding-top + padding-bottom do .square) */
    /* Se não houver padding no .square, use: height: calc(100% - 25px); */
}

.chart-wrapper canvas {
    max-width: 100%;
    max-height: 100%;
    display: block; /* Remove espaço extra abaixo do canvas */
}


.square:hover .edit-chart-btn {
    display: block;
}

/* Estilo do menu de edição que aparece no meio da tela */
.edit-menu {
    display: none; /* Inicialmente escondido */
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: #fff;
    border: 1px solid #ccc;
    padding: 20px;
    z-index: 100;
    width: 300px;
    box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
}

.edit-menu h2 {
    text-align: center;
    margin-bottom: 20px;
}

.edit-options label {
    display: block;
    margin-bottom: 5px;
}

.edit-options input {
    width: 100%;
    margin-bottom: 10px;
}

.edit-options button {
    width: 100%;
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 5px 10px;
    cursor: pointer;
    margin-bottom: 5px;
}

.edit-options button:hover {
    background-color: #d2b89f;
}

.close-btn {
    background-color: #f44336;
    color: #fff;
    border: none;
}

.close-btn:hover {
    background-color: #d32f2f;
}

/* Estilos para os botões de aplicar */
.apply-btn,
.apply-all-btn,
.reset-btn {
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 5px 10px;
    cursor: pointer;
}

.apply-btn:hover,
.apply-all-btn:hover,
.reset-btn:hover {
    background-color: #d2b89f;
}

/* Estilo para fechar o menu */
.close-btn {
    background-color: #f44336;
    color: #fff;
    border: none;
    padding: 5px 10px;
    cursor: pointer;
}

.close-btn:hover {
    background-color: #d32f2f;
}









/* Modal de Edição */
.modal-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 1400;
    padding: 20px;
    overflow-y: auto;
  }
  
  .edit-modal {
    background: #fff;
    border-radius: 8px;
    max-width: 1000px;
    width: 100%;
    margin: auto;
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
  }
  
  .edit-modal .graph-container {
    flex: 2 1 300px;
    position: relative;
    padding: 5px;
    background: #f9f9f9;
    border-radius: 4px;
    min-width: 250px;
    height: 700px; /* Tamanho fixo para o gráfico */
  }
  
  .edit-modal .settings-container {
    flex: 1 1 300px;
    padding: 10px;
    border-left: 1px solid #ddd;
    overflow-y: auto;
    min-width: 250px;
  }
  
  .settings-container h3 {
    margin-top: 0;
    text-align: center;
    font-size: 18px;
    margin-bottom: 10px;
  }
  
  .settings-group {
    margin-bottom: 12px;
  }
  
  .settings-group label {
    display: block;
    margin-bottom: 4px;
    font-weight: bold;
    font-size: 14px;
  }
  
  .settings-group input,
  .settings-group select {
    width: 100%;
    padding: 4px;
    font-size: 14px;
    box-sizing: border-box;
  }
  
  .group-color-item {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 4px;
  }
  










  .settings-buttons {
    margin-top: 15px;
    text-align: left;
  }
  
  .settings-buttons button {
    margin: 5px;
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    border: 1px solid #ccc;
    background-color: #e4d0b5;
    transition: background-color 0.3s;
  }
  
  .settings-buttons button:hover {
    background-color: #d2b89f;
  }
  
  .btn-group {
    display: inline-flex;
    align-items: left;
    border: 1px solid #ccc;
    border-radius: 4px;
    overflow: hidden;
    margin-right: 8px;
  }
  
  .btn-group button {
    border: none;
    background-color: #e4d0b5;
    padding: 6px 10px;
    cursor: pointer;
    font-size: 12px;
  }
  
  .btn-group select {
    border: none;
    padding: 6px 4px;
    font-size: 12px;
    outline: none;
    background-color: #ffffff;
  }
  


/* Separador entre gráfico e tabela */
.perguntas-separator {
    height: 25px;
    background-color: rgba(176, 196, 222, 0.5);
    width: 100%;
    display: flex;
    justify-content: flex-end;
    align-items: center;
    cursor: pointer;
    border-top: 1px solid #ccc;
    border-bottom: 1px solid #ccc;
    box-sizing: border-box;
    flex-shrink: 0; /* Evita que o separador encolha */
}

/* Botão de recolher/expandir */
.collapse-perguntas-btn {
    background: none;
    border: none;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    padding: 0 10px;
    line-height: 1; /* Ajusta altura da linha */
    color: #333;
    transition: transform 0.3s ease; /* Animação da seta */
}

/* Rotação da seta quando recolhido (requer JS para adicionar a classe 'collapsed') */
.collapse-perguntas-btn.collapsed {
    transform: rotate(180deg);
}

/* Wrapper para a tabela de perguntas */
.perguntas-table-wrapper {
    width: 100%;
    max-height: 200px; /* Mantido como altura máxima */
    /* Ajuste a altura se o gráfico tiver altura fixa */
    /* height: calc(600px - 5px - 350px - 25px - 5px); */ /* Exemplo: Total - padding sup - gráfico - separador - padding inf */
    overflow-y: auto;
    overflow-x: hidden;
    border: 1px solid #ddd;
    border-top: none;
    background-color: #f9f9f9;
    transition: max-height 0.4s ease-out, opacity 0.4s ease-out, padding 0.4s ease-out, border 0.4s ease-out;
    position: relative;
    padding: 0px;
    box-sizing: border-box;
    flex-shrink: 0; /* Evita que a tabela encolha */
}


/* Estilo da tabela de perguntas (pode ajustar conforme necessário) */
.perguntas-table-wrapper table {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px; /* Tamanho de fonte menor para perguntas */
}

.perguntas-table-wrapper th,
.perguntas-table-wrapper td {
    border: 1px solid #ccc;
    padding: 6px;
    text-align: left;
    vertical-align: top; /* Alinha texto no topo da célula */
    word-break: break-word; /* Quebra palavras longas */
}

.perguntas-table-wrapper th {
    background-color: #e0e8f0; /* Cor um pouco diferente para cabeçalho */
    font-weight: bold;
}

.perguntas-table-wrapper td:first-child { /* Coluna 'Grupo' */
    font-weight: bold;
    width: 100px; /* Largura fixa para coluna Grupo */
    background-color: #f0f5fa;
}

/* Estado recolhido da tabela */
.perguntas-table-wrapper.collapsed {
    max-height: 0;
    border-width: 0 1px;
    opacity: 0;
    overflow: hidden;
    padding-top: 0;
    padding-bottom: 0;
}

.square.capture-full-content .perguntas-table-wrapper {
    max-height: none !important; /* Remove limite de altura */
    overflow: visible !important; /* Mostra todo o conteúdo */
    height: auto !important;     /* Altura se ajusta ao conteúdo */
}


.square.capture-full-content div[id^="tableContainer_"] {
    max-height: none !important;
    overflow: visible !important;
    height: auto !important;
}


/* Opcional: Garante que o square tenha espaço suficiente durante a captura */
.square.capture-full-content {
    height: auto !important; /* Permite que o square cresça com o conteúdo */
    overflow: visible !important;
}




/* Botão de Edição específico para o Gráfico */
.edit-chart-btn {
    display: none;
     /* Estilos base do botão (copiados de edit-modal.css ou definidos aqui) */
    position: absolute; /* Redefine caso a regra do quadro seja sobrescrita */
    bottom: 5px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #e4d0b5;
    border: 1px solid #ccc;
    padding: 5px 5px;
    font-size: 14px;
    cursor: pointer;
    z-index: 10;
}

.chart-wrapper:hover .edit-chart-btn {
    display: block; /* Mostra no hover do wrapper do gráfico */
}

/* Mostra botão no hover do container da tabela */
#tableContainer:hover .edit-chart-btn { /* ID Genérico - Ajustar se necessário */
    display: block;
}

/* Botão de Edição específico para a Tabela de Perguntas */
.edit-perguntas-btn {
    display: none; /* Esconde por padrão (reforça, embora o JS já coloque inline) */
    position: sticky; 
    left: 50%;
    transform: translateX(-50%);
    bottom: 5px; /* Posição no wrapper da tabela */
    background-color: #c1d4e6; /* Cor diferente para teste */
    border: 1px solid #99b;
    padding: 5px 5px;
    font-size: 14px;
    cursor: pointer;
    z-index: 15; /* Acima do botão do gráfico, se houver sobreposição */
}

.perguntas-table-wrapper:hover .edit-perguntas-btn {
    display: block; /* Mostra no hover do wrapper da tabela */
}
/* === Filtros de Dimensão === */
.filter-buttons-container {
    text-align: center; /* Centraliza os botões */
    margin-bottom: 15px; /* Espaço abaixo dos botões */
    padding-bottom: 15px;
    border-bottom: 1px solid #eee; /* Linha separadora sutil */
}

.filter-btn {
    background-color: #f0f0f0;
    border: 1px solid #ccc;
    padding: 8px 15px; /* Aumenta um pouco o padding vertical */
    margin: 5px 5px; /* Adiciona espaço vertical entre linhas se quebrar */
    cursor: pointer;
    border-radius: 4px;
    font-size: 14px;
    transition: background-color 0.3s, box-shadow 0.3s, border-color 0.3s;
    color: #555;
    display: inline-block; /* Garante que margin funcione corretamente */
}

.filter-btn:hover {
    background-color: #e0e0e0;
    border-color: #bbb;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.filter-btn.active { /* Estilo do botão ativo */
    background-color: #b0c4de; /* Azul claro (sugestão, pode ajustar) */
    color: #fff; /* Texto branco para contraste */
    font-weight: bold;
    border-color: #9cb2cc; /* Borda um pouco mais escura */
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.15); /* Sombra interna */
}

/* Título da Dimensão Exibida */
.dimension-title-display {
    text-align: center;
    margin-top: 0; /* Remove margem superior padrão do h2 */
    margin-bottom: 25px; /* Espaço antes do grid */
    color: #444;
    font-size: 1.4em; /* Tamanho um pouco maior */
    font-weight: normal; /* Peso normal para não competir com H1 */
    /* border-bottom: 1px solid #eee; */ /* Removido - Já há borda nos botões */
    /* padding-bottom: 15px; */ /* Removido */
}

/* Ajuste para garantir que squares ocultos não ocupem espaço */
.square[style*="display: none"] {
    /* display: none !important; */ /* !important pode ser necessário se houver conflito */
    /* Outros estilos para ocultar completamente, se necessário */
     padding: 0;
     margin: 0;
     border: none;
     height: 0;
     overflow: hidden;
}

/* === Título da Dimensão (Separador Visual) === */
.dimension-separator-title {
    grid-column: 1 / -1; /* <<< Ocupa todas as colunas do grid */
    text-align: center;  /* <<< Centraliza o texto */
    margin: 40px 0 20px 0; /* Espaçamento acima e abaixo */
    padding-bottom: 10px; /* Espaço antes da linha */
    border-bottom: 2px solid #a0a0a0; /* Linha separadora mais forte */
    font-size: 1.6em; /* Tamanho maior */
    color: #333;
    font-weight: bold;
}
/* Remove margem superior do primeiro título de dimensão */
.grid-container > .dimension-separator-title:first-child {
    margin-top: 10px;
}


/* === Subtítulo do Indicador === */
.indicator-subtitle {
    /* Faz o subtítulo ocupar toda a largura da linha no grid */
    grid-column: 1 / -1; /* Começa na primeira linha de grade vertical e termina na última */

    /* Estilos visuais */
    font-size: 1.2em; /* Tamanho um pouco menor que o título da dimensão */
    font-weight: bold;
    color: #333; /* Cor escura */
    background-color: #e8f0fe; /* Um fundo azul bem claro para destacar levemente */
    padding: 8px 15px; /* Espaçamento interno */
    margin-top: 25px; /* Espaço ACIMA do subtítulo (separando do item anterior ou do título da dimensão) */
    margin-bottom: 10px; /* Espaço ABAIXO do subtítulo (antes dos gráficos) */
    border-left: 5px solid #b0c4de; /* Borda lateral para ênfase (cor do botão ativo) */
    border-radius: 3px;
    text-align: center; /* Alinhamento padrão */
    box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Sombra sutil */
}

/* Remove margem superior do PRIMEIRO subtítulo para não ficar muito longe dos filtros/título */
.grid-container > .indicator-subtitle:first-of-type {
    margin-top: 10px;
}

/* === Tabela de Informações Resumo === */
#info-summary-table-container {
    /* Reduz a largura máxima */
    max-width: 600px; /* Ajuste este valor como desejar */
    margin: 15px auto 25px auto;
    background-color: #f0f5fa;
    border: 1px solid #b0c4de;
    border-radius: 5px;
    padding: 10px 15px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

#info-summary-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
}

#info-summary-table th,
#info-summary-table td {
    border-bottom: 1px solid #d0d8e0;
    padding: 6px 8px;
    text-align: left;
    vertical-align: top;
}

#info-summary-table th {
    font-weight: bold;
    color: #334;
    width: 120px;
    white-space: nowrap;
}

#info-summary-table td {
    color: #445;
}

/* Remove borda da última linha geral */
#info-summary-table tr:last-child th,
#info-summary-table tr:last-child td {
    border-bottom: none;
}

/* --- NOVO/MODIFICADO: Estilo para cabeçalhos de seção --- */
#info-summary-table .info-header td,
#info-summary-table .counts-header td {
    font-weight: bold;
    text-align: center;
    padding-top: 12px;      /* Mais espaço acima */
    padding-bottom: 8px;     /* Espaço abaixo */
    color: #2a3a4a;          /* Cor um pouco mais escura */
    background-color: #e0e8f0; /* Cor de fundo ligeiramente diferente/destacada */
    border-bottom: 1px solid #b0c4de; /* Linha separadora abaixo */
    border-top: 1px solid #b0c4de;    /* Linha separadora acima */
}

/* Remove borda superior do PRIMEIRO cabeçalho */
#info-summary-table tr:first-child.info-header td {
     border-top: none;
}

/* Remove borda inferior do ÚLTIMO cabeçalho se for a última linha */
/* (Caso não haja grupos de respondentes) */
#info-summary-table tr:last-child.counts-header td {
     border-bottom: none;
}
/* --- FIM: Estilo cabeçalhos --- */


/* --- Estilos do Rodapé Fixo --- */
footer {
    position: fixed; /* Fixa o rodapé em relação à janela de visualização */
    bottom: 0;       /* Alinha na base da janela */
    left: 0;         /* Alinha na borda esquerda */
    right: 0;        /* Alinha na borda direita (garante largura total) */
    width: 100%;     /* Garante largura total (redundante com left/right: 0, mas seguro) */
    z-index: 1200;   /* Garante que fique acima da form-box (que tem z-index: 1100) */

    background-color: #e9edf2; /* Um fundo ligeiramente diferente para destaque */
    border-top: 1px solid #b0c4de; /* Borda superior mais visível */
    box-shadow: 0 -2px 5px rgba(0,0,0,0.1); /* Sombra sutil no topo */
    padding: 10px 15px; /* Padding interno (vertical um pouco menor) */
    box-sizing: border-box; /* Padding não aumenta a largura total */

    text-align: center;
    font-size: 0.85em;  /* Fonte pequena */
    color: #444;       /* Cor de texto */
    line-height: 1.4;  /* Espaçamento entre linhas */
}

footer p {
    margin: 0; /* Remove margem padrão do parágrafo */
}

footer a {
    color: #0056b3; /* Azul um pouco mais escuro para links */
    text-decoration: underline;
}

footer a:hover {
    text-decoration: none;
}

footer strong {
    font-weight: bold;
    color: #333; /* Destaca os labels "Desenvolvimento" e "Indicadores" */
}
/* --- Fim Estilos Rodapé --- */



/* Estilos para os ícones de ajuda e tooltips */

.help-icon {
    display: inline-block; /* Para aplicar dimensões e margens */
    width: 16px;           /* Tamanho do ícone */
    height: 16px;
    line-height: 16px;     /* Centraliza o '?' verticalmente */
    text-align: center;
    border-radius: 50%;    /* Deixa redondo */
    background-color: #6495ED; /* Cor de fundo (azul claro) */
    color: white;          /* Cor do '?' */
    font-weight: bold;
    font-size: 12px;
    cursor: help;          /* Muda o cursor ao passar o mouse */
    margin-left: 5px;      /* Espaçamento à esquerda */
    vertical-align: middle; /* Alinha com o texto ao redor */
    user-select: none;     /* Impede seleção do '?' */
  }
  
  .help-tooltip {
    position: absolute; /* Controlado pelo JS */
    background-color: #333; /* Fundo escuro */
    color: #fff;          /* Texto branco */
    padding: 8px 12px;   /* Espaçamento interno */
    border-radius: 4px;  /* Bordas arredondadas */
    font-size: 0.85em;   /* Tamanho da fonte menor */
    max-width: 250px;    /* Largura máxima antes de quebrar linha */
    opacity: 0;          /* Começa invisível (JS controla) */
    transition: opacity 0.2s ease-in-out; /* Transição suave (opcional) */
    z-index: 1500 !important;       /* Garante que fique acima */
    pointer-events: none;/* Impede interação com o tooltip em si */
    box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Sombra sutil */
  }